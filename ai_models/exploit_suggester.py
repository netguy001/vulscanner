"""
Exploit Suggester - AI-powered exploit recommendation and generation
Suggests exploitation techniques and generates working exploit code
"""

import json
from typing import Dict, List, Optional, Any
from .ollama_client import OllamaClient


class ExploitSuggester:
    """
    AI-powered exploit suggestion and code generation system
    """

    def __init__(self, ollama_client: OllamaClient):
        """
        Initialize exploit suggester

        Args:
            ollama_client: Initialized OllamaClient instance
        """
        self.client = ollama_client
        self.exploit_templates = {}

    def suggest_exploitation_techniques(
        self, vulnerability: Dict[str, Any]
    ) -> List[Dict[str, str]]:
        """
        Suggest multiple exploitation techniques for a vulnerability

        Args:
            vulnerability: Vulnerability details

        Returns:
            List of exploitation technique dicts
        """
        system_prompt = """You are an offensive security expert specializing in exploitation techniques.
Suggest creative, diverse, and practical exploitation methods for vulnerabilities."""

        prompt = f"""Suggest exploitation techniques for this vulnerability:

**Vulnerability:**
- Title: {vulnerability.get('title', 'Unknown')}
- Category: {vulnerability.get('category', 'Unknown')}
- Severity: {vulnerability.get('severity', 'Unknown')}
- Description: {vulnerability.get('description', 'No description')}

**Evidence:**
{json.dumps(vulnerability.get('evidence', {}), indent=2)}

**Provide 3-5 Different Exploitation Techniques:**

Return as JSON array with this structure:
{{
  "techniques": [
    {{
      "name": "Technique name",
      "description": "How it works",
      "difficulty": "Easy/Medium/Hard",
      "tools_required": ["tool1", "tool2"],
      "success_rate": "High/Medium/Low",
      "steps": [
        "Step 1 description",
        "Step 2 description"
      ],
      "expected_outcome": "What attacker achieves"
    }}
  ]
}}

Return ONLY valid JSON, no other text."""

        try:
            response = self.client.generate(
                prompt=prompt,
                temperature=0.7,
                max_tokens=2000,
                system_prompt=system_prompt,
            )

            if response:
                try:
                    response = (
                        response.replace("```json", "").replace("```", "").strip()
                    )
                    data = json.loads(response)
                    return data.get("techniques", [])
                except json.JSONDecodeError:
                    print("[!] Failed to parse exploitation techniques JSON")
                    return []
            return []

        except Exception as e:
            print(f"[!] Technique suggestion failed: {str(e)}")
            return []

    def generate_exploit_poc(
        self, vulnerability: Dict[str, Any], technique: Optional[str] = None
    ) -> Optional[str]:
        """
        Generate proof-of-concept exploit code

        Args:
            vulnerability: Vulnerability details
            technique: Specific exploitation technique (optional)

        Returns:
            Python exploit code or None
        """
        system_prompt = """You are an elite exploit developer creating proof-of-concept code.
Generate clean, well-commented, production-ready exploit scripts."""

        technique_context = f"\nUse this technique: {technique}" if technique else ""

        prompt = f"""Generate a complete proof-of-concept exploit for this vulnerability:

**Vulnerability:**
- Title: {vulnerability.get('title', 'Unknown')}
- Category: {vulnerability.get('category', 'Unknown')}
- Severity: {vulnerability.get('severity', 'Unknown')}
- Target: {vulnerability.get('affected_url', 'http://target.com')}
{technique_context}

**Evidence:**
{json.dumps(vulnerability.get('evidence', {}), indent=2)}

**Generate Complete Python Exploit with:**

1. Proper shebang and docstring
2. All necessary imports
3. Argument parsing (target URL, options)
4. Main exploit function
5. Verbose output showing each step
6. Success/failure detection
7. Safe execution (no destructive operations by default)
8. Clear comments explaining the exploitation process

**Required Structure:**
```python
#!/usr/bin/env python3
\"\"\"
PoC Exploit for: {vulnerability.get('title', 'Unknown')}
Category: {vulnerability.get('category', 'Unknown')}
Severity: {vulnerability.get('severity', 'Unknown')}

Description:
    [Brief exploitation description]

Usage:
    python3 exploit.py http://target.com
\"\"\"

import requests
import sys
import argparse
from urllib.parse import urljoin

def banner():
    print("="*60)
    print(f"PoC Exploit: {vulnerability.get('title', 'Unknown')}")
    print("="*60)

def exploit(target_url, verbose=True):
    \"\"\"
    Main exploit function
    
    Args:
        target_url: Target URL to exploit
        verbose: Print detailed progress
    \"\"\"
    if verbose:
        print(f"[*] Target: {{target_url}}")
        print("[*] Starting exploitation...")
    
    # Exploitation logic here
    try:
        # Step 1: [description]
        if verbose:
            print("[*] Step 1: ...")
        
        # Step 2: [description]
        if verbose:
            print("[*] Step 2: ...")
        
        # Validate success
        if verbose:
            print("[+] Exploitation successful!")
        
        return True
        
    except Exception as e:
        if verbose:
            print(f"[-] Exploitation failed: {{str(e)}}")
        return False

def main():
    parser = argparse.ArgumentParser(
        description='PoC Exploit for {vulnerability.get("title", "Unknown")}'
    )
    parser.add_argument('target', help='Target URL')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    
    args = parser.parse_args()
    
    banner()
    result = exploit(args.target, args.verbose)
    
    sys.exit(0 if result else 1)

if __name__ == "__main__":
    main()
```

Generate ONLY the complete Python code. Make it production-ready."""

        try:
            exploit_code = self.client.generate(
                prompt=prompt,
                temperature=0.7,
                max_tokens=3500,
                system_prompt=system_prompt,
            )

            if exploit_code:
                # Clean markdown fences
                exploit_code = (
                    exploit_code.replace("```python", "").replace("```", "").strip()
                )
                return exploit_code
            return None

        except Exception as e:
            print(f"[!] PoC generation failed: {str(e)}")
            return None

    def generate_automated_exploit(
        self, vulnerability: Dict[str, Any]
    ) -> Optional[str]:
        """
        Generate fully automated exploit with multiple payloads and techniques

        Args:
            vulnerability: Vulnerability details

        Returns:
            Advanced Python exploit framework code
        """
        system_prompt = """You are creating an advanced exploitation framework.
Generate intelligent, self-adapting exploit code that tries multiple techniques automatically."""

        prompt = f"""Generate an advanced automated exploit framework for:

**Vulnerability:**
- Title: {vulnerability.get('title', 'Unknown')}
- Category: {vulnerability.get('category', 'Unknown')}
- Severity: {vulnerability.get('severity', 'Unknown')}

**Requirements:**

1. Multiple exploitation techniques (at least 3 different approaches)
2. Automatic technique selection based on target responses
3. Payload rotation and WAF evasion
4. Result validation and proof capture
5. Detailed logging and reporting
6. Error recovery and retry logic
7. Safe mode (no destructive actions)

**Structure:**
- ExploitFramework class
- Multiple payload sets
- Technique methods
- Automatic exploitation method
- Result verification
- Report generation

Generate a complete, professional exploit framework in Python.
ONLY code, no explanations."""

        try:
            framework_code = self.client.generate(
                prompt=prompt,
                temperature=0.6,
                max_tokens=4000,
                system_prompt=system_prompt,
            )

            if framework_code:
                framework_code = (
                    framework_code.replace("```python", "").replace("```", "").strip()
                )
                return framework_code
            return None

        except Exception as e:
            print(f"[!] Framework generation failed: {str(e)}")
            return None

    def suggest_post_exploitation(
        self, vulnerability: Dict[str, Any], exploitation_result: Dict[str, Any]
    ) -> List[str]:
        """
        Suggest post-exploitation activities after successful exploit

        Args:
            vulnerability: Original vulnerability
            exploitation_result: Result of exploitation attempt

        Returns:
            List of post-exploitation suggestions
        """
        if not exploitation_result.get("success"):
            return []

        system_prompt = """You are a red team operator planning post-exploitation activities.
Suggest next steps after successful exploitation to maximize impact and persistence."""

        prompt = f"""Suggest post-exploitation activities after successfully exploiting:

**Exploited Vulnerability:**
- Title: {vulnerability.get('title', 'Unknown')}
- Category: {vulnerability.get('category', 'Unknown')}

**Exploitation Result:**
{json.dumps(exploitation_result, indent=2)}

**Suggest Next Steps:**
1. Data exfiltration opportunities
2. Privilege escalation paths
3. Lateral movement techniques
4. Persistence mechanisms
5. Evidence cleanup methods

Return as JSON array:
{{
  "post_exploitation": [
    {{
      "action": "Action name",
      "description": "What to do",
      "priority": "High/Medium/Low",
      "risk": "Low/Medium/High",
      "command": "Example command or code snippet"
    }}
  ]
}}

Return ONLY valid JSON."""

        try:
            response = self.client.generate(
                prompt=prompt,
                temperature=0.6,
                max_tokens=1500,
                system_prompt=system_prompt,
            )

            if response:
                try:
                    response = (
                        response.replace("```json", "").replace("```", "").strip()
                    )
                    data = json.loads(response)
                    return data.get("post_exploitation", [])
                except json.JSONDecodeError:
                    return []
            return []

        except Exception as e:
            print(f"[!] Post-exploitation suggestion failed: {str(e)}")
            return []

    def analyze_exploit_success(self, response_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Analyze HTTP response to determine if exploit was successful

        Args:
            response_data: HTTP response details (status, headers, body)

        Returns:
            Analysis of exploit success
        """
        system_prompt = """You are analyzing HTTP responses to determine exploitation success.
Identify indicators of compromise, successful exploitation, or failure."""

        prompt = f"""Analyze this HTTP response to determine if exploitation succeeded:

**Response Data:**
{json.dumps(response_data, indent=2)}

**Determine:**
1. Was exploitation successful? (Yes/No/Uncertain)
2. What indicators suggest success/failure?
3. What data was leaked/accessed?
4. What is the security impact?
5. What additional tests should be performed?

Return as JSON:
{{
  "success": true/false,
  "confidence": 0.95,
  "indicators": ["indicator1", "indicator2"],
  "leaked_data": ["data1", "data2"],
  "impact": "Description of impact",
  "next_steps": ["step1", "step2"]
}}

Return ONLY valid JSON."""

        try:
            response = self.client.generate(
                prompt=prompt,
                temperature=0.3,
                max_tokens=1000,
                system_prompt=system_prompt,
            )

            if response:
                try:
                    response = (
                        response.replace("```json", "").replace("```", "").strip()
                    )
                    return json.loads(response)
                except json.JSONDecodeError:
                    return {"error": "Failed to parse analysis"}
            return {"error": "No response from AI"}

        except Exception as e:
            return {"error": f"Analysis failed: {str(e)}"}

    def generate_waf_bypass_variants(
        self, original_payload: str, vulnerability_type: str
    ) -> List[str]:
        """
        Generate WAF bypass variants of a payload

        Args:
            original_payload: Original payload string
            vulnerability_type: Type of vulnerability (sql, xss, etc.)

        Returns:
            List of bypass variant payloads
        """
        system_prompt = """You are a WAF bypass specialist.
Generate creative payload variants that evade common WAF rules while maintaining effectiveness."""

        prompt = f"""Generate WAF bypass variants for this payload:

**Original Payload:**
{original_payload}

**Vulnerability Type:** {vulnerability_type}

**Generate 10 diverse bypass variants using:**
1. Encoding (URL, HTML, Unicode, Base64)
2. Case variation
3. Comment injection
4. Whitespace manipulation
5. Alternate syntax
6. Obfuscation techniques
7. Double encoding
8. Null byte injection
9. Character substitution
10. Protocol smuggling

Return as JSON array:
{{
  "variants": [
    {{"payload": "variant1", "technique": "technique name"}},
    {{"payload": "variant2", "technique": "technique name"}}
  ]
}}

Return ONLY valid JSON."""

        try:
            response = self.client.generate(
                prompt=prompt,
                temperature=0.8,
                max_tokens=2000,
                system_prompt=system_prompt,
            )

            if response:
                try:
                    response = (
                        response.replace("```json", "").replace("```", "").strip()
                    )
                    data = json.loads(response)
                    return [v["payload"] for v in data.get("variants", [])]
                except json.JSONDecodeError:
                    return []
            return []

        except Exception as e:
            print(f"[!] WAF bypass generation failed: {str(e)}")
            return []

    def save_exploit_template(self, name: str, code: str):
        """Save exploit code as reusable template"""
        self.exploit_templates[name] = code

    def get_exploit_template(self, name: str) -> Optional[str]:
        """Retrieve saved exploit template"""
        return self.exploit_templates.get(name)

    def list_exploit_templates(self) -> List[str]:
        """List all saved exploit templates"""
        return list(self.exploit_templates.keys())
